// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataUtil
#include <flixel/util/FlxBitmapDataUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif

namespace flixel{
namespace util{

void FlxBitmapDataUtil_obj::__construct() { }

Dynamic FlxBitmapDataUtil_obj::__CreateEmpty() { return new FlxBitmapDataUtil_obj; }

hx::ObjectPtr< FlxBitmapDataUtil_obj > FlxBitmapDataUtil_obj::__new()
{
	hx::ObjectPtr< FlxBitmapDataUtil_obj > _hx_result = new FlxBitmapDataUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic FlxBitmapDataUtil_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxBitmapDataUtil_obj > _hx_result = new FlxBitmapDataUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::flixel::math::FlxMatrix FlxBitmapDataUtil_obj::matrix;

void FlxBitmapDataUtil_obj::merge( ::openfl::_legacy::display::BitmapData sourceBitmapData, ::openfl::_legacy::geom::Rectangle sourceRect, ::openfl::_legacy::display::BitmapData destBitmapData, ::openfl::_legacy::geom::Point destPoint,Int redMultiplier,Int greenMultiplier,Int blueMultiplier,Int alphaMultiplier){
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","merge",0x21db12bd,"flixel.util.FlxBitmapDataUtil.merge","flixel/util/FlxBitmapDataUtil.hx",32,0xf477b24b)
            	HX_STACK_ARG(sourceBitmapData,"sourceBitmapData")
            	HX_STACK_ARG(sourceRect,"sourceRect")
            	HX_STACK_ARG(destBitmapData,"destBitmapData")
            	HX_STACK_ARG(destPoint,"destPoint")
            	HX_STACK_ARG(redMultiplier,"redMultiplier")
            	HX_STACK_ARG(greenMultiplier,"greenMultiplier")
            	HX_STACK_ARG(blueMultiplier,"blueMultiplier")
            	HX_STACK_ARG(alphaMultiplier,"alphaMultiplier")
HXLINE(  36)		Bool _hx_tmp;
HXDLIN(  36)		Bool _hx_tmp1;
HXDLIN(  36)		Bool _hx_tmp2;
HXDLIN(  36)		Bool _hx_tmp3;
HXDLIN(  36)		Bool _hx_tmp4;
HXDLIN(  36)		Float _hx_tmp5 = destPoint->x;
HXDLIN(  36)		Int _hx_tmp6 = destBitmapData->get_width();
HXDLIN(  36)		if (!((_hx_tmp5 >= _hx_tmp6))) {
HXLINE(  37)			Float _hx_tmp7 = destPoint->y;
HXDLIN(  37)			Int _hx_tmp8 = destBitmapData->get_height();
HXLINE(  36)			_hx_tmp4 = (_hx_tmp7 >= _hx_tmp8);
            		}
            		else {
HXLINE(  36)			_hx_tmp4 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp4)) {
HXLINE(  38)			Float _hx_tmp9 = sourceRect->x;
HXDLIN(  38)			Int _hx_tmp10 = sourceBitmapData->get_width();
HXLINE(  36)			_hx_tmp3 = (_hx_tmp9 >= _hx_tmp10);
            		}
            		else {
HXLINE(  36)			_hx_tmp3 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp3)) {
HXLINE(  39)			Float _hx_tmp11 = sourceRect->y;
HXDLIN(  39)			Int _hx_tmp12 = sourceBitmapData->get_height();
HXLINE(  36)			_hx_tmp2 = (_hx_tmp11 >= _hx_tmp12);
            		}
            		else {
HXLINE(  36)			_hx_tmp2 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp2)) {
HXLINE(  36)			_hx_tmp1 = ((sourceRect->x + sourceRect->width) <= (int)0);
            		}
            		else {
HXLINE(  36)			_hx_tmp1 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp1)) {
HXLINE(  36)			_hx_tmp = ((sourceRect->y + sourceRect->height) <= (int)0);
            		}
            		else {
HXLINE(  36)			_hx_tmp = true;
            		}
HXDLIN(  36)		if (_hx_tmp) {
HXLINE(  43)			return;
            		}
HXLINE(  47)		while(true){
HXLINE(  47)			Bool _hx_tmp13;
HXDLIN(  47)			Bool _hx_tmp14;
HXDLIN(  47)			Bool _hx_tmp15;
HXDLIN(  47)			Bool _hx_tmp16;
HXDLIN(  47)			Bool _hx_tmp17;
HXDLIN(  47)			Float _hx_tmp18 = (sourceRect->x + sourceRect->width);
HXDLIN(  47)			Int _hx_tmp19 = sourceBitmapData->get_width();
HXDLIN(  47)			if (!((_hx_tmp18 > _hx_tmp19))) {
HXLINE(  48)				Float _hx_tmp20 = (sourceRect->y + sourceRect->height);
HXDLIN(  48)				Int _hx_tmp21 = sourceBitmapData->get_height();
HXLINE(  47)				_hx_tmp17 = (_hx_tmp20 > _hx_tmp21);
            			}
            			else {
HXLINE(  47)				_hx_tmp17 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp17)) {
HXLINE(  47)				_hx_tmp16 = (sourceRect->x < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp16 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp16)) {
HXLINE(  47)				_hx_tmp15 = (sourceRect->y < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp15 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp15)) {
HXLINE(  47)				_hx_tmp14 = (destPoint->x < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp14 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp14)) {
HXLINE(  47)				_hx_tmp13 = (destPoint->y < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp13 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp13)) {
HXLINE(  47)				goto _hx_goto_0;
            			}
HXLINE(  54)			Float _hx_tmp22 = (sourceRect->x + sourceRect->width);
HXDLIN(  54)			Int _hx_tmp23 = sourceBitmapData->get_width();
HXDLIN(  54)			if ((_hx_tmp22 > _hx_tmp23)) {
HXLINE(  54)				Int _hx_tmp24 = sourceBitmapData->get_width();
HXDLIN(  54)				sourceRect->width = (_hx_tmp24 - sourceRect->x);
            			}
HXLINE(  55)			Float _hx_tmp25 = (sourceRect->y + sourceRect->height);
HXDLIN(  55)			Int _hx_tmp26 = sourceBitmapData->get_height();
HXDLIN(  55)			if ((_hx_tmp25 > _hx_tmp26)) {
HXLINE(  55)				Int _hx_tmp27 = sourceBitmapData->get_height();
HXDLIN(  55)				sourceRect->height = (_hx_tmp27 - sourceRect->y);
            			}
HXLINE(  57)			Bool _hx_tmp28 = (sourceRect->x < (int)0);
HXDLIN(  57)			if (_hx_tmp28) {
HXLINE(  59)				destPoint->x = (destPoint->x - sourceRect->x);
HXLINE(  60)				sourceRect->width = (sourceRect->width + sourceRect->x);
HXLINE(  61)				sourceRect->x = (int)0;
            			}
HXLINE(  64)			Bool _hx_tmp29 = (sourceRect->y < (int)0);
HXDLIN(  64)			if (_hx_tmp29) {
HXLINE(  66)				destPoint->y = (destPoint->y - sourceRect->y);
HXLINE(  67)				sourceRect->height = (sourceRect->height + sourceRect->y);
HXLINE(  68)				sourceRect->y = (int)0;
            			}
HXLINE(  71)			Bool _hx_tmp30;
HXDLIN(  71)			Float _hx_tmp31 = destPoint->x;
HXDLIN(  71)			Int _hx_tmp32 = destBitmapData->get_width();
HXDLIN(  71)			if (!((_hx_tmp31 >= _hx_tmp32))) {
HXLINE(  71)				Float _hx_tmp33 = destPoint->y;
HXDLIN(  71)				Int _hx_tmp34 = destBitmapData->get_height();
HXDLIN(  71)				_hx_tmp30 = (_hx_tmp33 >= _hx_tmp34);
            			}
            			else {
HXLINE(  71)				_hx_tmp30 = true;
            			}
HXDLIN(  71)			if (_hx_tmp30) {
HXLINE(  71)				return;
            			}
HXLINE(  73)			Bool _hx_tmp35 = (destPoint->x < (int)0);
HXDLIN(  73)			if (_hx_tmp35) {
HXLINE(  75)				sourceRect->x = (sourceRect->x - destPoint->x);
HXLINE(  76)				sourceRect->width = (sourceRect->width + destPoint->x);
HXLINE(  77)				destPoint->x = (int)0;
            			}
HXLINE(  80)			Bool _hx_tmp36 = (destPoint->y < (int)0);
HXDLIN(  80)			if (_hx_tmp36) {
HXLINE(  82)				sourceRect->y = (sourceRect->y - destPoint->y);
HXLINE(  83)				sourceRect->height = (sourceRect->height + destPoint->y);
HXLINE(  84)				destPoint->y = (int)0;
            			}
            		}
            		_hx_goto_0:;
HXLINE(  88)		Bool _hx_tmp37;
HXDLIN(  88)		if (!((sourceRect->width <= (int)0))) {
HXLINE(  88)			_hx_tmp37 = (sourceRect->height <= (int)0);
            		}
            		else {
HXLINE(  88)			_hx_tmp37 = true;
            		}
HXDLIN(  88)		if (_hx_tmp37) {
HXLINE(  88)			return;
            		}
HXLINE(  90)		HX_VARI( Int,startSourceX) = ::Math_obj::round(sourceRect->x);
HXLINE(  91)		HX_VARI( Int,startSourceY) = ::Math_obj::round(sourceRect->y);
HXLINE(  93)		HX_VARI( Int,width) = ::Math_obj::round(sourceRect->width);
HXLINE(  94)		HX_VARI( Int,height) = ::Math_obj::round(sourceRect->height);
HXLINE(  96)		HX_VARI( Int,sourceX) = startSourceX;
HXLINE(  97)		HX_VARI( Int,sourceY) = startSourceY;
HXLINE(  99)		HX_VARI( Int,destX) = ::Math_obj::round(destPoint->x);
HXLINE( 100)		HX_VARI( Int,destY) = ::Math_obj::round(destPoint->y);
HXLINE( 102)		HX_VARI( Int,currX) = destX;
HXLINE( 103)		HX_VARI( Int,currY) = destY;
HXLINE( 105)		HX_VAR( Int,sourceColor);
HXLINE( 106)		HX_VAR( Int,destColor);
HXLINE( 108)		HX_VAR( Int,resultRed);
HXLINE( 109)		HX_VAR( Int,resultGreen);
HXLINE( 110)		HX_VAR( Int,resultBlue);
HXLINE( 111)		HX_VAR( Int,resultAlpha);
HXLINE( 113)		HX_VARI( Int,resultColor) = (int)0;
HXLINE( 114)		destBitmapData->lock();
HXLINE( 117)		{
HXLINE( 117)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 117)			while((_g1 < width)){
HXLINE( 117)				HX_VARI( Int,i) = _g1++;
HXLINE( 119)				{
HXLINE( 119)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 119)					while((_g3 < height)){
HXLINE( 119)						HX_VARI( Int,j) = _g3++;
HXLINE( 121)						sourceX = (startSourceX + i);
HXLINE( 122)						sourceY = (startSourceY + j);
HXLINE( 124)						currX = (destX + i);
HXLINE( 125)						currY = (destY + j);
HXLINE( 127)						sourceColor = sourceBitmapData->getPixel32(sourceX,sourceY);
HXLINE( 128)						destColor = destBitmapData->getPixel32(currX,currY);
HXLINE( 131)						resultRed = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)16) & (int)(int)255) * redMultiplier) + (((int)((int)destColor >> (int)(int)16) & (int)(int)255) * ((int)256 - redMultiplier))) / (Float)(int)256));
HXLINE( 132)						resultGreen = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)8) & (int)(int)255) * greenMultiplier) + (((int)((int)destColor >> (int)(int)8) & (int)(int)255) * ((int)256 - greenMultiplier))) / (Float)(int)256));
HXLINE( 133)						resultBlue = ::Std_obj::_hx_int(((Float)((((int)sourceColor & (int)(int)255) * blueMultiplier) + (((int)destColor & (int)(int)255) * ((int)256 - blueMultiplier))) / (Float)(int)256));
HXLINE( 134)						resultAlpha = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)24) & (int)(int)255) * alphaMultiplier) + (((int)((int)destColor >> (int)(int)24) & (int)(int)255) * ((int)256 - alphaMultiplier))) / (Float)(int)256));
HXLINE( 137)						HX_VARI( Int,color) = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 137)						{
HXLINE( 137)							hx::AndEq(color,(int)-16711681);
HXDLIN( 137)							Int _hx_tmp38;
HXDLIN( 137)							if ((resultRed > (int)255)) {
HXLINE( 137)								_hx_tmp38 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultRed < (int)0)) {
HXLINE( 137)									_hx_tmp38 = (int)0;
            								}
            								else {
HXLINE( 137)									_hx_tmp38 = resultRed;
            								}
            							}
HXDLIN( 137)							hx::OrEq(color,((int)_hx_tmp38 << (int)(int)16));
            						}
HXDLIN( 137)						{
HXLINE( 137)							hx::AndEq(color,(int)-65281);
HXDLIN( 137)							Int _hx_tmp39;
HXDLIN( 137)							if ((resultGreen > (int)255)) {
HXLINE( 137)								_hx_tmp39 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultGreen < (int)0)) {
HXLINE( 137)									_hx_tmp39 = (int)0;
            								}
            								else {
HXLINE( 137)									_hx_tmp39 = resultGreen;
            								}
            							}
HXDLIN( 137)							hx::OrEq(color,((int)_hx_tmp39 << (int)(int)8));
            						}
HXDLIN( 137)						{
HXLINE( 137)							hx::AndEq(color,(int)-256);
HXDLIN( 137)							Int _hx_tmp40;
HXDLIN( 137)							if ((resultBlue > (int)255)) {
HXLINE( 137)								_hx_tmp40 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultBlue < (int)0)) {
HXLINE( 137)									_hx_tmp40 = (int)0;
            								}
            								else {
HXLINE( 137)									_hx_tmp40 = resultBlue;
            								}
            							}
HXDLIN( 137)							hx::OrEq(color,_hx_tmp40);
            						}
HXDLIN( 137)						{
HXLINE( 137)							hx::AndEq(color,(int)16777215);
HXDLIN( 137)							Int _hx_tmp41;
HXDLIN( 137)							if ((resultAlpha > (int)255)) {
HXLINE( 137)								_hx_tmp41 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultAlpha < (int)0)) {
HXLINE( 137)									_hx_tmp41 = (int)0;
            								}
            								else {
HXLINE( 137)									_hx_tmp41 = resultAlpha;
            								}
            							}
HXDLIN( 137)							hx::OrEq(color,((int)_hx_tmp41 << (int)(int)24));
            						}
HXDLIN( 137)						resultColor = color;
HXLINE( 140)						destBitmapData->setPixel32(currX,currY,resultColor);
            					}
            				}
            			}
            		}
HXLINE( 143)		destBitmapData->unlock(null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(FlxBitmapDataUtil_obj,merge,(void))

Int FlxBitmapDataUtil_obj::mergeColorComponent(Int source,Int dest,Int multiplier){
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","mergeColorComponent",0x5b71b277,"flixel.util.FlxBitmapDataUtil.mergeColorComponent","flixel/util/FlxBitmapDataUtil.hx",149,0xf477b24b)
            	HX_STACK_ARG(source,"source")
            	HX_STACK_ARG(dest,"dest")
            	HX_STACK_ARG(multiplier,"multiplier")
HXLINE( 149)		return ::Std_obj::_hx_int(((Float)((source * multiplier) + (dest * ((int)256 - multiplier))) / (Float)(int)256));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxBitmapDataUtil_obj,mergeColorComponent,return )

 ::Dynamic FlxBitmapDataUtil_obj::compare( ::openfl::_legacy::display::BitmapData Bitmap1, ::openfl::_legacy::display::BitmapData Bitmap2){
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","compare",0x217d53ea,"flixel.util.FlxBitmapDataUtil.compare","flixel/util/FlxBitmapDataUtil.hx",164,0xf477b24b)
            	HX_STACK_ARG(Bitmap1,"Bitmap1")
            	HX_STACK_ARG(Bitmap2,"Bitmap2")
HXLINE( 168)		if (hx::IsEq( Bitmap1,Bitmap2 )) {
HXLINE( 170)			return (int)0;
            		}
HXLINE( 172)		Int _hx_tmp = Bitmap1->get_width();
HXDLIN( 172)		Int _hx_tmp1 = Bitmap2->get_width();
HXDLIN( 172)		if ((_hx_tmp != _hx_tmp1)) {
HXLINE( 174)			return (int)-3;
            		}
            		else {
HXLINE( 176)			Int _hx_tmp2 = Bitmap1->get_height();
HXDLIN( 176)			Int _hx_tmp3 = Bitmap2->get_height();
HXDLIN( 176)			if ((_hx_tmp2 != _hx_tmp3)) {
HXLINE( 178)				return (int)-4;
            			}
            			else {
HXLINE( 182)				HX_VARI( Int,width) = Bitmap1->get_width();
HXLINE( 183)				HX_VARI( Int,height) = Bitmap1->get_height();
HXLINE( 184)				HX_VARI(  ::openfl::_legacy::display::BitmapData,result) =  ::openfl::_legacy::display::BitmapData_obj::__new(width,height,true,(int)0,null());
HXLINE( 185)				HX_VARI( Bool,identical) = true;
HXLINE( 187)				{
HXLINE( 187)					HX_VARI( Int,_g1) = (int)0;
HXDLIN( 187)					while((_g1 < width)){
HXLINE( 187)						HX_VARI( Int,i) = _g1++;
HXLINE( 189)						{
HXLINE( 189)							HX_VARI( Int,_g3) = (int)0;
HXDLIN( 189)							while((_g3 < height)){
HXLINE( 189)								HX_VARI( Int,j) = _g3++;
HXLINE( 191)								HX_VARI( Int,pixel1) = Bitmap1->getPixel32(i,j);
HXLINE( 192)								HX_VARI( Int,pixel2) = Bitmap2->getPixel32(i,j);
HXLINE( 194)								if ((pixel1 != pixel2)) {
HXLINE( 196)									identical = false;
HXLINE( 198)									if ((((int)pixel1 & (int)(int)16777215) != ((int)pixel2 & (int)(int)16777215))) {
HXLINE( 201)										HX_VARI( Int,diff) = (((int)((int)pixel1 >> (int)(int)16) & (int)(int)255) - ((int)((int)pixel2 >> (int)(int)16) & (int)(int)255));
HXLINE( 200)										HX_VAR( Int,Red);
HXLINE( 201)										if ((diff >= (int)0)) {
HXLINE( 200)											Red = diff;
            										}
            										else {
HXLINE( 200)											Red = ((int)256 + diff);
            										}
HXLINE( 202)										HX_VARI_NAME( Int,diff1,"diff") = (((int)((int)pixel1 >> (int)(int)8) & (int)(int)255) - ((int)((int)pixel2 >> (int)(int)8) & (int)(int)255));
HXLINE( 200)										HX_VAR( Int,Green);
HXLINE( 202)										if ((diff1 >= (int)0)) {
HXLINE( 200)											Green = diff1;
            										}
            										else {
HXLINE( 200)											Green = ((int)256 + diff1);
            										}
HXLINE( 203)										HX_VARI_NAME( Int,diff2,"diff") = (((int)pixel1 & (int)(int)255) - ((int)pixel2 & (int)(int)255));
HXLINE( 200)										HX_VAR( Int,Blue);
HXLINE( 203)										if ((diff2 >= (int)0)) {
HXLINE( 200)											Blue = diff2;
            										}
            										else {
HXLINE( 200)											Blue = ((int)256 + diff2);
            										}
HXDLIN( 200)										HX_VARI( Int,color) = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 200)										{
HXLINE( 200)											hx::AndEq(color,(int)-16711681);
HXDLIN( 200)											Int _hx_tmp4;
HXDLIN( 200)											if ((Red > (int)255)) {
HXLINE( 200)												_hx_tmp4 = (int)255;
            											}
            											else {
HXLINE( 200)												if ((Red < (int)0)) {
HXLINE( 200)													_hx_tmp4 = (int)0;
            												}
            												else {
HXLINE( 200)													_hx_tmp4 = Red;
            												}
            											}
HXDLIN( 200)											hx::OrEq(color,((int)_hx_tmp4 << (int)(int)16));
            										}
HXDLIN( 200)										{
HXLINE( 200)											hx::AndEq(color,(int)-65281);
HXDLIN( 200)											Int _hx_tmp5;
HXDLIN( 200)											if ((Green > (int)255)) {
HXLINE( 200)												_hx_tmp5 = (int)255;
            											}
            											else {
HXLINE( 200)												if ((Green < (int)0)) {
HXLINE( 200)													_hx_tmp5 = (int)0;
            												}
            												else {
HXLINE( 200)													_hx_tmp5 = Green;
            												}
            											}
HXDLIN( 200)											hx::OrEq(color,((int)_hx_tmp5 << (int)(int)8));
            										}
HXDLIN( 200)										{
HXLINE( 200)											hx::AndEq(color,(int)-256);
HXDLIN( 200)											Int _hx_tmp6;
HXDLIN( 200)											if ((Blue > (int)255)) {
HXLINE( 200)												_hx_tmp6 = (int)255;
            											}
            											else {
HXLINE( 200)												if ((Blue < (int)0)) {
HXLINE( 200)													_hx_tmp6 = (int)0;
            												}
            												else {
HXLINE( 200)													_hx_tmp6 = Blue;
            												}
            											}
HXDLIN( 200)											hx::OrEq(color,_hx_tmp6);
            										}
HXDLIN( 200)										{
HXLINE( 200)											hx::AndEq(color,(int)16777215);
HXDLIN( 200)											hx::OrEq(color,(int)-16777216);
            										}
HXDLIN( 200)										result->setPixel32(i,j,color);
            									}
            									else {
HXLINE( 208)										HX_VARI( Int,alpha1) = ((int)((int)pixel1 >> (int)(int)24) & (int)(int)255);
HXLINE( 209)										HX_VARI( Int,alpha2) = ((int)((int)pixel2 >> (int)(int)24) & (int)(int)255);
HXLINE( 211)										if ((alpha1 != alpha2)) {
HXLINE( 214)											HX_VARI_NAME( Int,diff3,"diff") = (alpha1 - alpha2);
HXLINE( 213)											HX_VAR( Int,Alpha);
HXLINE( 214)											if ((diff3 >= (int)0)) {
HXLINE( 213)												Alpha = diff3;
            											}
            											else {
HXLINE( 213)												Alpha = ((int)256 + diff3);
            											}
HXDLIN( 213)											HX_VARI_NAME( Int,color1,"color") = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 213)											{
HXLINE( 213)												hx::AndEq(color1,(int)-16711681);
HXDLIN( 213)												hx::OrEq(color1,(int)16711680);
            											}
HXDLIN( 213)											{
HXLINE( 213)												hx::AndEq(color1,(int)-65281);
HXDLIN( 213)												hx::OrEq(color1,(int)65280);
            											}
HXDLIN( 213)											{
HXLINE( 213)												hx::AndEq(color1,(int)-256);
HXDLIN( 213)												hx::OrEq(color1,(int)255);
            											}
HXDLIN( 213)											{
HXLINE( 213)												hx::AndEq(color1,(int)16777215);
HXDLIN( 213)												Int _hx_tmp7;
HXDLIN( 213)												if ((Alpha > (int)255)) {
HXLINE( 213)													_hx_tmp7 = (int)255;
            												}
            												else {
HXLINE( 213)													if ((Alpha < (int)0)) {
HXLINE( 213)														_hx_tmp7 = (int)0;
            													}
            													else {
HXLINE( 213)														_hx_tmp7 = Alpha;
            													}
            												}
HXDLIN( 213)												hx::OrEq(color1,((int)_hx_tmp7 << (int)(int)24));
            											}
HXDLIN( 213)											result->setPixel32(i,j,color1);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXLINE( 221)				if (!(identical)) {
HXLINE( 223)					return result;
            				}
            			}
            		}
HXLINE( 227)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,compare,return )

Int FlxBitmapDataUtil_obj::getDiff(Int value1,Int value2){
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","getDiff",0xb3004700,"flixel.util.FlxBitmapDataUtil.getDiff","flixel/util/FlxBitmapDataUtil.hx",232,0xf477b24b)
            	HX_STACK_ARG(value1,"value1")
            	HX_STACK_ARG(value2,"value2")
HXLINE( 233)		HX_VARI( Int,diff) = (value1 - value2);
HXLINE( 234)		if ((diff >= (int)0)) {
HXLINE( 234)			return diff;
            		}
            		else {
HXLINE( 234)			return ((int)256 + diff);
            		}
HXDLIN( 234)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,getDiff,return )

Float FlxBitmapDataUtil_obj::getMemorySize( ::openfl::_legacy::display::BitmapData bitmapData){
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","getMemorySize",0x5bc2859d,"flixel.util.FlxBitmapDataUtil.getMemorySize","flixel/util/FlxBitmapDataUtil.hx",242,0xf477b24b)
            	HX_STACK_ARG(bitmapData,"bitmapData")
HXLINE( 242)		Int _hx_tmp = bitmapData->get_width();
HXDLIN( 242)		Int _hx_tmp1 = bitmapData->get_height();
HXDLIN( 242)		return ((_hx_tmp * _hx_tmp1) * (int)4);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapDataUtil_obj,getMemorySize,return )

::Array< ::Dynamic> FlxBitmapDataUtil_obj::replaceColor( ::openfl::_legacy::display::BitmapData bitmapData,Int color,Int newColor,hx::Null< Bool >  __o_fetchPositions, ::flixel::math::FlxRect rect){
Bool fetchPositions = __o_fetchPositions.Default(false);
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","replaceColor",0xbc41272a,"flixel.util.FlxBitmapDataUtil.replaceColor","flixel/util/FlxBitmapDataUtil.hx",257,0xf477b24b)
            	HX_STACK_ARG(bitmapData,"bitmapData")
            	HX_STACK_ARG(color,"color")
            	HX_STACK_ARG(newColor,"newColor")
            	HX_STACK_ARG(fetchPositions,"fetchPositions")
            	HX_STACK_ARG(rect,"rect")
HXLINE( 258)		HX_VARI( ::Array< ::Dynamic>,positions) = null();
HXLINE( 259)		if (fetchPositions) {
HXLINE( 261)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 264)		HX_VARI( Int,startX) = (int)0;
HXLINE( 265)		HX_VARI( Int,startY) = (int)0;
HXLINE( 266)		HX_VARI( Int,columns) = bitmapData->get_width();
HXLINE( 267)		HX_VARI( Int,rows) = bitmapData->get_height();
HXLINE( 269)		Bool _hx_tmp = hx::IsNotNull( rect );
HXDLIN( 269)		if (_hx_tmp) {
HXLINE( 271)			startX = ::Std_obj::_hx_int(rect->x);
HXLINE( 272)			startY = ::Std_obj::_hx_int(rect->y);
HXLINE( 273)			columns = ::Std_obj::_hx_int(rect->width);
HXLINE( 274)			rows = ::Std_obj::_hx_int(rect->height);
            		}
HXLINE( 277)		Int _hx_tmp1 = bitmapData->get_width();
HXDLIN( 277)		Float _hx_tmp2 = ::Math_obj::max(columns,_hx_tmp1);
HXDLIN( 277)		columns = ::Std_obj::_hx_int(_hx_tmp2);
HXLINE( 278)		Int _hx_tmp3 = bitmapData->get_height();
HXDLIN( 278)		Float _hx_tmp4 = ::Math_obj::max(rows,_hx_tmp3);
HXDLIN( 278)		rows = ::Std_obj::_hx_int(_hx_tmp4);
HXLINE( 280)		HX_VARI( Int,row) = (int)0;
HXLINE( 281)		HX_VARI( Int,column) = (int)0;
HXLINE( 282)		HX_VAR( Int,x);
HXDLIN( 282)		HX_VAR( Int,y);
HXLINE( 284)		HX_VARI( Bool,changed) = false;
HXLINE( 285)		bitmapData->lock();
HXLINE( 286)		while((row < rows)){
HXLINE( 288)			column = (int)0;
HXLINE( 289)			while((column < columns)){
HXLINE( 291)				x = (startX + column);
HXLINE( 292)				y = (startY + row);
HXLINE( 293)				Int _hx_tmp5 = bitmapData->getPixel32(x,y);
HXDLIN( 293)				if ((_hx_tmp5 == color)) {
HXLINE( 295)					bitmapData->setPixel32(x,y,newColor);
HXLINE( 296)					changed = true;
HXLINE( 297)					if (fetchPositions) {
HXLINE( 299)						HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get()->set(x,y);
HXDLIN( 299)						point->_inPool = false;
HXDLIN( 299)						positions->push(point);
            					}
            				}
HXLINE( 302)				++column;
            			}
HXLINE( 304)			++row;
            		}
HXLINE( 306)		bitmapData->unlock(null());
HXLINE( 308)		Bool _hx_tmp6;
HXDLIN( 308)		if (changed) {
HXLINE( 308)			_hx_tmp6 = hx::IsNull( positions );
            		}
            		else {
HXLINE( 308)			_hx_tmp6 = false;
            		}
HXDLIN( 308)		if (_hx_tmp6) {
HXLINE( 310)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 313)		return positions;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,replaceColor,return )

 ::openfl::_legacy::display::BitmapData FlxBitmapDataUtil_obj::addSpacesAndBorders( ::openfl::_legacy::display::BitmapData bitmapData, ::flixel::math::FlxPoint frameSize, ::flixel::math::FlxPoint spacing, ::flixel::math::FlxPoint border, ::flixel::math::FlxRect region){
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","addSpacesAndBorders",0xf8f1a643,"flixel.util.FlxBitmapDataUtil.addSpacesAndBorders","flixel/util/FlxBitmapDataUtil.hx",326,0xf477b24b)
            	HX_STACK_ARG(bitmapData,"bitmapData")
            	HX_STACK_ARG(frameSize,"frameSize")
            	HX_STACK_ARG(spacing,"spacing")
            	HX_STACK_ARG(border,"border")
            	HX_STACK_ARG(region,"region")
HXLINE( 327)		Bool _hx_tmp = hx::IsNull( region );
HXDLIN( 327)		if (_hx_tmp) {
HXLINE( 329)			Float Width = bitmapData->get_width();
HXDLIN( 329)			Float Height = bitmapData->get_height();
HXDLIN( 329)			HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 329)			_this->x = (int)0;
HXDLIN( 329)			_this->y = (int)0;
HXDLIN( 329)			_this->width = Width;
HXDLIN( 329)			_this->height = Height;
HXDLIN( 329)			_this->_inPool = false;
HXDLIN( 329)			region = _this;
            		}
HXLINE( 332)		HX_VARI( Int,frameWidth) = ::Std_obj::_hx_int(region->width);
HXLINE( 333)		HX_VARI( Int,frameHeight) = ::Std_obj::_hx_int(region->height);
HXLINE( 335)		Bool _hx_tmp1 = hx::IsNotNull( frameSize );
HXDLIN( 335)		if (_hx_tmp1) {
HXLINE( 337)			frameWidth = ::Std_obj::_hx_int(frameSize->x);
HXLINE( 338)			frameHeight = ::Std_obj::_hx_int(frameSize->y);
            		}
HXLINE( 341)		Float _hx_tmp2 = ((Float)region->width / (Float)frameWidth);
HXDLIN( 341)		HX_VARI( Int,numHorizontalFrames) = ::Std_obj::_hx_int(_hx_tmp2);
HXLINE( 342)		Float _hx_tmp3 = ((Float)region->height / (Float)frameHeight);
HXDLIN( 342)		HX_VARI( Int,numVerticalFrames) = ::Std_obj::_hx_int(_hx_tmp3);
HXLINE( 344)		HX_VARI( Int,spaceX) = (int)0;
HXLINE( 345)		HX_VARI( Int,spaceY) = (int)0;
HXLINE( 347)		Bool _hx_tmp4 = hx::IsNotNull( spacing );
HXDLIN( 347)		if (_hx_tmp4) {
HXLINE( 349)			spaceX = ::Std_obj::_hx_int(spacing->x);
HXLINE( 350)			spaceY = ::Std_obj::_hx_int(spacing->y);
            		}
HXLINE( 353)		HX_VARI( Int,borderX) = (int)0;
HXLINE( 354)		HX_VARI( Int,borderY) = (int)0;
HXLINE( 356)		Bool _hx_tmp5 = hx::IsNotNull( border );
HXDLIN( 356)		if (_hx_tmp5) {
HXLINE( 358)			borderX = ::Std_obj::_hx_int(border->x);
HXLINE( 359)			borderY = ::Std_obj::_hx_int(border->y);
            		}
HXLINE( 363)		Float _hx_tmp6 = (region->width + ((numHorizontalFrames - (int)1) * spaceX));
HXDLIN( 363)		Int _hx_tmp7 = ::Std_obj::_hx_int((_hx_tmp6 + (((int)2 * numHorizontalFrames) * borderX)));
HXLINE( 364)		Float _hx_tmp8 = (region->height + ((numVerticalFrames - (int)1) * spaceY));
HXDLIN( 364)		Int _hx_tmp9 = ::Std_obj::_hx_int((_hx_tmp8 + (((int)2 * numVerticalFrames) * borderY)));
HXLINE( 362)		HX_VARI(  ::openfl::_legacy::display::BitmapData,result) =  ::openfl::_legacy::display::BitmapData_obj::__new(_hx_tmp7,_hx_tmp9,true,(int)0,null());
HXLINE( 368)		result->lock();
HXLINE( 369)		HX_VARI(  ::openfl::_legacy::geom::Rectangle,tempRect) =  ::openfl::_legacy::geom::Rectangle_obj::__new((int)0,(int)0,frameWidth,frameHeight);
HXLINE( 370)		HX_VARI(  ::openfl::_legacy::geom::Point,tempPoint) =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
HXLINE( 373)		{
HXLINE( 373)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 373)			while((_g1 < numHorizontalFrames)){
HXLINE( 373)				HX_VARI( Int,i) = _g1++;
HXLINE( 375)				tempPoint->x = ((i * ((frameWidth + spaceX) + ((int)2 * borderX))) + borderX);
HXLINE( 376)				tempRect->x = ((i * frameWidth) + region->x);
HXLINE( 378)				{
HXLINE( 378)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 378)					while((_g3 < numVerticalFrames)){
HXLINE( 378)						HX_VARI( Int,j) = _g3++;
HXLINE( 380)						tempPoint->y = ((j * ((frameHeight + spaceY) + ((int)2 * borderY))) + borderY);
HXLINE( 381)						tempRect->y = ((j * frameHeight) + region->y);
HXLINE( 382)						result->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 385)		result->unlock(null());
HXLINE( 388)		::flixel::util::FlxBitmapDataUtil_obj::copyBorderPixels(result,frameWidth,frameHeight,spaceX,spaceY,borderX,borderY,numHorizontalFrames,numVerticalFrames);
HXLINE( 389)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,addSpacesAndBorders,return )

 ::openfl::_legacy::display::BitmapData FlxBitmapDataUtil_obj::copyBorderPixels( ::openfl::_legacy::display::BitmapData bitmapData,Int frameWidth,Int frameHeight,Int spaceX,Int spaceY,Int borderX,Int borderY,Int horizontalFrames,Int verticalFrames){
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","copyBorderPixels",0x739e20a9,"flixel.util.FlxBitmapDataUtil.copyBorderPixels","flixel/util/FlxBitmapDataUtil.hx",409,0xf477b24b)
            	HX_STACK_ARG(bitmapData,"bitmapData")
            	HX_STACK_ARG(frameWidth,"frameWidth")
            	HX_STACK_ARG(frameHeight,"frameHeight")
            	HX_STACK_ARG(spaceX,"spaceX")
            	HX_STACK_ARG(spaceY,"spaceY")
            	HX_STACK_ARG(borderX,"borderX")
            	HX_STACK_ARG(borderY,"borderY")
            	HX_STACK_ARG(horizontalFrames,"horizontalFrames")
            	HX_STACK_ARG(verticalFrames,"verticalFrames")
HXLINE( 411)		Int _hx_tmp = bitmapData->get_height();
HXDLIN( 411)		HX_VARI(  ::openfl::_legacy::geom::Rectangle,tempRect) =  ::openfl::_legacy::geom::Rectangle_obj::__new((int)0,(int)0,(int)1,_hx_tmp);
HXLINE( 412)		HX_VARI(  ::openfl::_legacy::geom::Point,tempPoint) =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
HXLINE( 413)		bitmapData->lock();
HXLINE( 415)		{
HXLINE( 415)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 415)			while((_g1 < horizontalFrames)){
HXLINE( 415)				HX_VARI( Int,i) = _g1++;
HXLINE( 417)				tempRect->x = ((i * ((frameWidth + ((int)2 * borderX)) + spaceX)) + borderX);
HXLINE( 419)				{
HXLINE( 419)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 419)					while((_g3 < borderX)){
HXLINE( 419)						HX_VARI( Int,j) = _g3++;
HXLINE( 421)						Float _hx_tmp1 = (tempRect->x - j);
HXDLIN( 421)						tempPoint->x = (_hx_tmp1 - (int)1);
HXLINE( 422)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 425)				hx::AddEq(tempRect->x,(frameWidth - (int)1));
HXLINE( 427)				{
HXLINE( 427)					HX_VARI_NAME( Int,_g31,"_g3") = (int)0;
HXDLIN( 427)					while((_g31 < borderX)){
HXLINE( 427)						HX_VARI_NAME( Int,j1,"j") = _g31++;
HXLINE( 429)						Float _hx_tmp2 = (tempRect->x + j1);
HXDLIN( 429)						tempPoint->x = (_hx_tmp2 + (int)1);
HXLINE( 430)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 434)		tempPoint->setTo((int)0,(int)0);
HXLINE( 435)		Int _hx_tmp3 = bitmapData->get_width();
HXDLIN( 435)		tempRect->setTo((int)0,(int)0,_hx_tmp3,(int)1);
HXLINE( 436)		{
HXLINE( 436)			HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 436)			while((_g11 < verticalFrames)){
HXLINE( 436)				HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE( 438)				tempRect->y = ((i1 * ((frameHeight + ((int)2 * borderY)) + spaceY)) + borderY);
HXLINE( 440)				{
HXLINE( 440)					HX_VARI_NAME( Int,_g32,"_g3") = (int)0;
HXDLIN( 440)					while((_g32 < borderY)){
HXLINE( 440)						HX_VARI_NAME( Int,j2,"j") = _g32++;
HXLINE( 442)						Float _hx_tmp4 = (tempRect->y - j2);
HXDLIN( 442)						tempPoint->y = (_hx_tmp4 - (int)1);
HXLINE( 443)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 446)				hx::AddEq(tempRect->y,(frameHeight - (int)1));
HXLINE( 448)				{
HXLINE( 448)					HX_VARI_NAME( Int,_g33,"_g3") = (int)0;
HXDLIN( 448)					while((_g33 < borderY)){
HXLINE( 448)						HX_VARI_NAME( Int,j3,"j") = _g33++;
HXLINE( 450)						Float _hx_tmp5 = (tempRect->y + j3);
HXDLIN( 450)						tempPoint->y = (_hx_tmp5 + (int)1);
HXLINE( 451)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 455)		bitmapData->unlock(null());
HXLINE( 456)		return bitmapData;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FlxBitmapDataUtil_obj,copyBorderPixels,return )

 ::openfl::_legacy::display::BitmapData FlxBitmapDataUtil_obj::generateRotations( ::openfl::_legacy::display::BitmapData brush,hx::Null< Int >  __o_rotations,hx::Null< Bool >  __o_antiAliasing,hx::Null< Bool >  __o_autoBuffer){
Int rotations = __o_rotations.Default(16);
Bool antiAliasing = __o_antiAliasing.Default(false);
Bool autoBuffer = __o_autoBuffer.Default(false);
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","generateRotations",0xe085af05,"flixel.util.FlxBitmapDataUtil.generateRotations","flixel/util/FlxBitmapDataUtil.hx",469,0xf477b24b)
            	HX_STACK_ARG(brush,"brush")
            	HX_STACK_ARG(rotations,"rotations")
            	HX_STACK_ARG(antiAliasing,"antiAliasing")
            	HX_STACK_ARG(autoBuffer,"autoBuffer")
HXLINE( 470)		HX_VARI( Int,brushWidth) = brush->get_width();
HXLINE( 471)		HX_VARI( Int,brushHeight) = brush->get_height();
HXLINE( 472)		HX_VAR( Int,max);
HXDLIN( 472)		if ((brushHeight > brushWidth)) {
HXLINE( 472)			max = brushHeight;
            		}
            		else {
HXLINE( 472)			max = brushWidth;
            		}
HXLINE( 473)		if (autoBuffer) {
HXLINE( 473)			max = ::Std_obj::_hx_int((max * ((Float)1.5)));
            		}
            		else {
HXLINE( 473)			max = max;
            		}
HXLINE( 475)		Float _hx_tmp = ::Math_obj::sqrt(rotations);
HXDLIN( 475)		HX_VARI( Int,rows) = ::Std_obj::_hx_int(_hx_tmp);
HXLINE( 476)		HX_VARI( Int,columns) = ::Math_obj::ceil(((Float)rotations / (Float)rows));
HXLINE( 477)		HX_VARI( Float,bakedRotationAngle) = ((Float)(int)360 / (Float)rotations);
HXLINE( 482)		HX_VARI(  ::openfl::_legacy::display::BitmapData,result) =  ::openfl::_legacy::display::BitmapData_obj::__new((max * columns),(max * rows),true,(int)0,null());
HXLINE( 484)		HX_VARI( Int,row) = (int)0;
HXLINE( 485)		HX_VARI( Int,column) = (int)0;
HXLINE( 486)		HX_VARI( Float,bakedAngle) = (int)0;
HXLINE( 487)		HX_VARI( Int,halfBrushWidth) = ::Std_obj::_hx_int((brushWidth * ((Float)0.5)));
HXLINE( 488)		HX_VARI( Int,halfBrushHeight) = ::Std_obj::_hx_int((brushHeight * ((Float)0.5)));
HXLINE( 489)		HX_VARI( Int,midpointX) = ::Std_obj::_hx_int((max * ((Float)0.5)));
HXLINE( 490)		HX_VARI( Int,midpointY) = ::Std_obj::_hx_int((max * ((Float)0.5)));
HXLINE( 492)		while((row < rows)){
HXLINE( 494)			column = (int)0;
HXLINE( 495)			while((column < columns)){
HXLINE( 497)				::flixel::util::FlxBitmapDataUtil_obj::matrix->identity();
HXLINE( 498)				::flixel::util::FlxBitmapDataUtil_obj::matrix->translate(-(halfBrushWidth),-(halfBrushHeight));
HXLINE( 499)				Float _hx_tmp1 = (bakedAngle * ((Float)::Math_obj::PI / (Float)(int)180));
HXDLIN( 499)				::flixel::util::FlxBitmapDataUtil_obj::matrix->rotate(_hx_tmp1);
HXLINE( 500)				::flixel::util::FlxBitmapDataUtil_obj::matrix->translate(((max * column) + midpointX),midpointY);
HXLINE( 501)				hx::AddEq(bakedAngle,bakedRotationAngle);
HXLINE( 502)				result->draw(brush,::flixel::util::FlxBitmapDataUtil_obj::matrix,null(),null(),null(),antiAliasing);
HXLINE( 503)				++column;
            			}
HXLINE( 505)			hx::AddEq(midpointY,max);
HXLINE( 506)			++row;
            		}
HXLINE( 509)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxBitmapDataUtil_obj,generateRotations,return )


FlxBitmapDataUtil_obj::FlxBitmapDataUtil_obj()
{
}

bool FlxBitmapDataUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"merge") ) { outValue = merge_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { outValue = matrix; return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"compare") ) { outValue = compare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getDiff") ) { outValue = getDiff_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"replaceColor") ) { outValue = replaceColor_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getMemorySize") ) { outValue = getMemorySize_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"copyBorderPixels") ) { outValue = copyBorderPixels_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"generateRotations") ) { outValue = generateRotations_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"mergeColorComponent") ) { outValue = mergeColorComponent_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addSpacesAndBorders") ) { outValue = addSpacesAndBorders_dyn(); return true; }
	}
	return false;
}

bool FlxBitmapDataUtil_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=ioValue.Cast<  ::flixel::math::FlxMatrix >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxBitmapDataUtil_obj_sMemberStorageInfo = 0;
static hx::StaticInfo FlxBitmapDataUtil_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::flixel::math::FlxMatrix*/ ,(void *) &FlxBitmapDataUtil_obj::matrix,HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void FlxBitmapDataUtil_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxBitmapDataUtil_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxBitmapDataUtil_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxBitmapDataUtil_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#endif

hx::Class FlxBitmapDataUtil_obj::__mClass;

static ::String FlxBitmapDataUtil_obj_sStaticFields[] = {
	HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"),
	HX_HCSTRING("merge","\xb8","\xa2","\xc6","\x05"),
	HX_HCSTRING("mergeColorComponent","\xb2","\x23","\x8f","\xc5"),
	HX_HCSTRING("compare","\xa5","\x18","\x69","\x83"),
	HX_HCSTRING("getDiff","\xbb","\x0b","\xec","\x14"),
	HX_HCSTRING("getMemorySize","\x98","\x08","\x07","\x4f"),
	HX_HCSTRING("replaceColor","\x8f","\x5c","\xeb","\x3d"),
	HX_HCSTRING("addSpacesAndBorders","\x7e","\x17","\x0f","\x63"),
	HX_HCSTRING("copyBorderPixels","\x8e","\x6c","\x7f","\x76"),
	HX_HCSTRING("generateRotations","\x80","\xcb","\xc6","\x62"),
	::String(null())
};

void FlxBitmapDataUtil_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.util.FlxBitmapDataUtil","\xb3","\x4e","\x39","\xe9");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxBitmapDataUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxBitmapDataUtil_obj::__SetStatic;
	__mClass->mMarkFunc = FlxBitmapDataUtil_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxBitmapDataUtil_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxBitmapDataUtil_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxBitmapDataUtil_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxBitmapDataUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxBitmapDataUtil_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxBitmapDataUtil_obj::__boot()
{
{
            	HX_STACK_FRAME("flixel.util.FlxBitmapDataUtil","boot",0x2db7bbcd,"flixel.util.FlxBitmapDataUtil.boot","flixel/util/FlxBitmapDataUtil.hx",17,0xf477b24b)
HXLINE(  17)		matrix =  ::flixel::math::FlxMatrix_obj::__new(null(),null(),null(),null(),null(),null());
            	}
}

} // end namespace flixel
} // end namespace util
