// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringBuf
#include <StringBuf.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_DebuggerFrontEnd
#include <flixel/system/frontEnds/DebuggerFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_util_LabelValuePair
#include <flixel/util/FlxPool_flixel_util_LabelValuePair.h>
#endif
#ifndef INCLUDED_flixel_util_FlxStringUtil
#include <flixel/util/FlxStringUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_LabelValuePair
#include <flixel/util/LabelValuePair.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl__legacy_AssetType
#include <openfl/_legacy/AssetType.h>
#endif
#ifndef INCLUDED_openfl__legacy_Assets
#include <openfl/_legacy/Assets.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif

static const ::String _hx_array_data_4[] = {
	HX_("Bytes",4b,78,c5,50),HX_("kB",77,5d,00,00),HX_("MB",55,43,00,00),HX_("GB",1b,3e,00,00),HX_("TB",6e,49,00,00),HX_("PB",f2,45,00,00),
};
namespace flixel{
namespace util{

void FlxStringUtil_obj::__construct() { }

Dynamic FlxStringUtil_obj::__CreateEmpty() { return new FlxStringUtil_obj; }

hx::ObjectPtr< FlxStringUtil_obj > FlxStringUtil_obj::__new()
{
	hx::ObjectPtr< FlxStringUtil_obj > _hx_result = new FlxStringUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic FlxStringUtil_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxStringUtil_obj > _hx_result = new FlxStringUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

::String FlxStringUtil_obj::formatTicks(Int StartTicks,Int EndTicks){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","formatTicks",0xe4bb609c,"flixel.util.FlxStringUtil.formatTicks","flixel/util/FlxStringUtil.hx",27,0x4e012e33)
            	HX_STACK_ARG(StartTicks,"StartTicks")
            	HX_STACK_ARG(EndTicks,"EndTicks")
HXLINE(  27)		Float _hx_tmp = ::Math_obj::abs((EndTicks - StartTicks));
HXDLIN(  27)		return (((Float)_hx_tmp / (Float)(int)1000) + HX_("s",73,00,00,00));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxStringUtil_obj,formatTicks,return )

::String FlxStringUtil_obj::formatTime(Float Seconds,hx::Null< Bool >  __o_ShowMS){
Bool ShowMS = __o_ShowMS.Default(false);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","formatTime",0xcfa9a0a7,"flixel.util.FlxStringUtil.formatTime","flixel/util/FlxStringUtil.hx",38,0x4e012e33)
            	HX_STACK_ARG(Seconds,"Seconds")
            	HX_STACK_ARG(ShowMS,"ShowMS")
HXLINE(  39)		Int _hx_tmp = ::Std_obj::_hx_int(((Float)Seconds / (Float)(int)60));
HXDLIN(  39)		HX_VARI( ::String,timeString) = (_hx_tmp + HX_(":",3a,00,00,00));
HXLINE(  40)		Int _hx_tmp1 = ::Std_obj::_hx_int(Seconds);
HXDLIN(  40)		HX_VARI( Int,timeStringHelper) = hx::Mod(_hx_tmp1,(int)60);
HXLINE(  41)		if ((timeStringHelper < (int)10)) {
HXLINE(  43)			hx::AddEq(timeString,HX_("0",30,00,00,00));
            		}
HXLINE(  45)		hx::AddEq(timeString,timeStringHelper);
HXLINE(  46)		if (ShowMS) {
HXLINE(  48)			hx::AddEq(timeString,HX_(".",2e,00,00,00));
HXLINE(  49)			Int _hx_tmp2 = ::Std_obj::_hx_int(Seconds);
HXDLIN(  49)			timeStringHelper = ::Std_obj::_hx_int(((Seconds - _hx_tmp2) * (int)100));
HXLINE(  50)			if ((timeStringHelper < (int)10)) {
HXLINE(  52)				hx::AddEq(timeString,HX_("0",30,00,00,00));
            			}
HXLINE(  54)			hx::AddEq(timeString,timeStringHelper);
            		}
HXLINE(  57)		return timeString;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxStringUtil_obj,formatTime,return )

::String FlxStringUtil_obj::formatArray(::cpp::VirtualArray AnyArray){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","formatArray",0xfa1c9fbf,"flixel.util.FlxStringUtil.formatArray","flixel/util/FlxStringUtil.hx",68,0x4e012e33)
            	HX_STACK_ARG(AnyArray,"AnyArray")
HXLINE(  69)		HX_VARI( ::String,string) = HX_("",00,00,00,00);
HXLINE(  70)		Bool _hx_tmp;
HXDLIN(  70)		Bool _hx_tmp1 = hx::IsNotNull( AnyArray );
HXDLIN(  70)		if (_hx_tmp1) {
HXLINE(  70)			_hx_tmp = (AnyArray->get_length() > (int)0);
            		}
            		else {
HXLINE(  70)			_hx_tmp = false;
            		}
HXDLIN(  70)		if (_hx_tmp) {
HXLINE(  72)			 ::Dynamic _hx_tmp2 = AnyArray->__get((int)0);
HXDLIN(  72)			string = ::Std_obj::string(_hx_tmp2);
HXLINE(  73)			HX_VARI( Int,i) = (int)1;
HXLINE(  74)			HX_VARI( Int,l) = AnyArray->get_length();
HXLINE(  75)			while((i < l)){
HXLINE(  77)				Int _hx_tmp3 = i++;
HXDLIN(  77)				 ::Dynamic _hx_tmp4 = AnyArray->__get(_hx_tmp3);
HXDLIN(  77)				::String _hx_tmp5 = ::Std_obj::string(_hx_tmp4);
HXDLIN(  77)				hx::AddEq(string,(HX_(", ",74,26,00,00) + _hx_tmp5));
            			}
            		}
HXLINE(  80)		return string;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,formatArray,return )

::String FlxStringUtil_obj::formatStringMap( ::haxe::ds::StringMap AnyMap){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","formatStringMap",0x51016f71,"flixel.util.FlxStringUtil.formatStringMap","flixel/util/FlxStringUtil.hx",90,0x4e012e33)
            	HX_STACK_ARG(AnyMap,"AnyMap")
HXLINE(  91)		HX_VARI( ::String,string) = HX_("",00,00,00,00);
HXLINE(  92)		{
HXLINE(  92)			HX_VARI(  ::Dynamic,tmp) = AnyMap->keys();
HXDLIN(  92)			while(true){
HXLINE(  92)				Bool _hx_tmp = !(( (Bool)( ::Dynamic(tmp->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic))()) ));
HXDLIN(  92)				if (_hx_tmp) {
HXLINE(  92)					goto _hx_goto_1;
            				}
HXDLIN(  92)				HX_VARI( ::String,key) = ( (::String)( ::Dynamic(tmp->__Field(HX_("next",f3,84,02,49),hx::paccDynamic))()) );
HXLINE(  94)				::String _hx_tmp1 = ::Std_obj::string(key);
HXDLIN(  94)				hx::AddEq(string,_hx_tmp1);
HXLINE(  95)				hx::AddEq(string,HX_(", ",74,26,00,00));
            			}
            			_hx_goto_1:;
            		}
HXLINE(  98)		Int _hx_tmp2 = (string.length - (int)2);
HXDLIN(  98)		return string.substring((int)0,_hx_tmp2);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,formatStringMap,return )

::String FlxStringUtil_obj::formatMoney(Float Amount,hx::Null< Bool >  __o_ShowDecimal,hx::Null< Bool >  __o_EnglishStyle){
Bool ShowDecimal = __o_ShowDecimal.Default(true);
Bool EnglishStyle = __o_EnglishStyle.Default(true);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","formatMoney",0xe0ecec66,"flixel.util.FlxStringUtil.formatMoney","flixel/util/FlxStringUtil.hx",113,0x4e012e33)
            	HX_STACK_ARG(Amount,"Amount")
            	HX_STACK_ARG(ShowDecimal,"ShowDecimal")
            	HX_STACK_ARG(EnglishStyle,"EnglishStyle")
HXLINE( 114)		HX_VARI( Bool,isNegative) = (Amount < (int)0);
HXLINE( 115)		Amount = ::Math_obj::abs(Amount);
HXLINE( 117)		HX_VARI( ::String,string) = HX_("",00,00,00,00);
HXLINE( 118)		HX_VARI( ::String,comma) = HX_("",00,00,00,00);
HXLINE( 119)		HX_VARI( Int,amount) = ::Math_obj::floor(Amount);
HXLINE( 120)		while((amount > (int)0)){
HXLINE( 122)			Bool _hx_tmp;
HXDLIN( 122)			if ((string.length > (int)0)) {
HXLINE( 122)				_hx_tmp = (comma.length <= (int)0);
            			}
            			else {
HXLINE( 122)				_hx_tmp = false;
            			}
HXDLIN( 122)			if (_hx_tmp) {
HXLINE( 123)				if (EnglishStyle) {
HXLINE( 123)					comma = HX_(",",2c,00,00,00);
            				}
            				else {
HXLINE( 123)					comma = HX_(".",2e,00,00,00);
            				}
            			}
HXLINE( 125)			HX_VARI( ::String,zeroes) = HX_("",00,00,00,00);
HXLINE( 126)			Int _hx_tmp1 = ::Math_obj::floor(((Float)amount / (Float)(int)1000));
HXDLIN( 126)			HX_VARI( Int,helper) = (amount - (_hx_tmp1 * (int)1000));
HXLINE( 127)			amount = ::Math_obj::floor(((Float)amount / (Float)(int)1000));
HXLINE( 128)			if ((amount > (int)0)) {
HXLINE( 130)				if ((helper < (int)100)) {
HXLINE( 131)					zeroes = HX_("0",30,00,00,00);
            				}
HXLINE( 132)				if ((helper < (int)10)) {
HXLINE( 133)					hx::AddEq(zeroes,HX_("0",30,00,00,00));
            				}
            			}
HXLINE( 135)			string = (((zeroes + helper) + comma) + string);
            		}
HXLINE( 138)		Bool _hx_tmp2 = (string == HX_("",00,00,00,00));
HXDLIN( 138)		if (_hx_tmp2) {
HXLINE( 139)			string = HX_("0",30,00,00,00);
            		}
HXLINE( 141)		if (ShowDecimal) {
HXLINE( 143)			Int _hx_tmp3 = ::Math_obj::floor((Amount * (int)100));
HXDLIN( 143)			Int _hx_tmp4 = ::Math_obj::floor(Amount);
HXDLIN( 143)			amount = (_hx_tmp3 - (_hx_tmp4 * (int)100));
HXLINE( 144)			::String _hx_tmp5;
HXDLIN( 144)			if (EnglishStyle) {
HXLINE( 144)				_hx_tmp5 = HX_(".",2e,00,00,00);
            			}
            			else {
HXLINE( 144)				_hx_tmp5 = HX_(",",2c,00,00,00);
            			}
HXDLIN( 144)			hx::AddEq(string,(_hx_tmp5 + amount));
HXLINE( 145)			if ((amount < (int)10)) {
HXLINE( 146)				hx::AddEq(string,HX_("0",30,00,00,00));
            			}
            		}
HXLINE( 149)		if (isNegative) {
HXLINE( 150)			string = (HX_("-",2d,00,00,00) + string);
            		}
HXLINE( 151)		return string;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxStringUtil_obj,formatMoney,return )

::String FlxStringUtil_obj::formatBytes(Float Bytes,hx::Null< Int >  __o_Precision){
Int Precision = __o_Precision.Default(2);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","formatBytes",0x92253a91,"flixel.util.FlxStringUtil.formatBytes","flixel/util/FlxStringUtil.hx",159,0x4e012e33)
            	HX_STACK_ARG(Bytes,"Bytes")
            	HX_STACK_ARG(Precision,"Precision")
HXLINE( 160)		HX_VARI( ::Array< ::String >,units) = ::Array_obj< ::String >::fromData( _hx_array_data_4,6);
HXLINE( 161)		HX_VARI( Int,curUnit) = (int)0;
HXLINE( 162)		while(true){
HXLINE( 162)			Bool _hx_tmp;
HXDLIN( 162)			if ((Bytes >= (int)1024)) {
HXLINE( 162)				_hx_tmp = (curUnit < (units->length - (int)1));
            			}
            			else {
HXLINE( 162)				_hx_tmp = false;
            			}
HXDLIN( 162)			if (!(_hx_tmp)) {
HXLINE( 162)				goto _hx_goto_3;
            			}
HXLINE( 164)			hx::DivEq(Bytes,(int)1024);
HXLINE( 165)			++curUnit;
            		}
            		_hx_goto_3:;
HXLINE( 167)		Float _hx_tmp1 = ::flixel::math::FlxMath_obj::roundDecimal(Bytes,Precision);
HXDLIN( 167)		return (_hx_tmp1 + units->__get(curUnit));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxStringUtil_obj,formatBytes,return )

::String FlxStringUtil_obj::filterDigits(::String Input){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","filterDigits",0xab6a2081,"flixel.util.FlxStringUtil.filterDigits","flixel/util/FlxStringUtil.hx",177,0x4e012e33)
            	HX_STACK_ARG(Input,"Input")
HXLINE( 178)		HX_VARI(  ::StringBuf,output) =  ::StringBuf_obj::__new();
HXLINE( 179)		{
HXLINE( 179)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 179)			HX_VARI( Int,_g) = Input.length;
HXDLIN( 179)			while((_g1 < _g)){
HXLINE( 179)				HX_VARI( Int,i) = _g1++;
HXLINE( 181)				HX_VARI(  ::Dynamic,c) = Input.charCodeAt(i);
HXLINE( 182)				Bool _hx_tmp;
HXDLIN( 182)				if (hx::IsGreaterEq( c,(int)48 )) {
HXLINE( 182)					_hx_tmp = hx::IsLessEq( c,(int)57 );
            				}
            				else {
HXLINE( 182)					_hx_tmp = false;
            				}
HXDLIN( 182)				if (_hx_tmp) {
HXLINE( 184)					Int c1 = c;
HXDLIN( 184)					Bool _hx_tmp1 = hx::IsNull( output->charBuf );
HXDLIN( 184)					if (_hx_tmp1) {
HXLINE( 184)						output->charBuf = ::Array_obj< char >::__new();
            					}
HXDLIN( 184)					output->charBuf->push(c1);
            				}
            			}
            		}
HXLINE( 187)		Bool _hx_tmp2 = hx::IsNotNull( output->charBuf );
HXDLIN( 187)		if (_hx_tmp2) {
HXLINE( 187)			output->flush();
            		}
HXDLIN( 187)		return output->b->join(HX_("",00,00,00,00));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,filterDigits,return )

::String FlxStringUtil_obj::htmlFormat(::String Text,hx::Null< Int >  __o_Size,::String __o_Color,hx::Null< Bool >  __o_Bold,hx::Null< Bool >  __o_Italic,hx::Null< Bool >  __o_Underlined){
Int Size = __o_Size.Default(12);
::String Color = __o_Color.Default(HX_HCSTRING("FFFFFF","\xc0","\x27","\x82","\x79"));
Bool Bold = __o_Bold.Default(false);
Bool Italic = __o_Italic.Default(false);
Bool Underlined = __o_Underlined.Default(false);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","htmlFormat",0x8e97acc5,"flixel.util.FlxStringUtil.htmlFormat","flixel/util/FlxStringUtil.hx",203,0x4e012e33)
            	HX_STACK_ARG(Text,"Text")
            	HX_STACK_ARG(Size,"Size")
            	HX_STACK_ARG(Color,"Color")
            	HX_STACK_ARG(Bold,"Bold")
            	HX_STACK_ARG(Italic,"Italic")
            	HX_STACK_ARG(Underlined,"Underlined")
HXLINE( 204)		HX_VARI( ::String,prefix) = ((((HX_("<font size='",c0,5b,1a,a4) + Size) + HX_("' color='#",2f,1d,64,33)) + Color) + HX_("'>",37,22,00,00));
HXLINE( 205)		HX_VARI( ::String,suffix) = HX_("</font>",3c,82,5f,8e);
HXLINE( 207)		if (Bold) {
HXLINE( 209)			prefix = (HX_("<b>",d8,dc,2d,00) + prefix);
HXLINE( 210)			suffix = (HX_("</font>",3c,82,5f,8e) + HX_("</b>",cf,cc,cc,27));
            		}
HXLINE( 212)		if (Italic) {
HXLINE( 214)			prefix = (HX_("<i>",f1,e2,2d,00) + prefix);
HXLINE( 215)			hx::AddEq(suffix,HX_("</i>",e8,d2,cc,27));
            		}
HXLINE( 217)		if (Underlined) {
HXLINE( 219)			prefix = (HX_("<u>",65,ed,2d,00) + prefix);
HXLINE( 220)			hx::AddEq(suffix,HX_("</u>",5c,dd,cc,27));
            		}
HXLINE( 223)		return ((prefix + Text) + suffix);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(FlxStringUtil_obj,htmlFormat,return )

::String FlxStringUtil_obj::getDomain(::String url){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","getDomain",0x05683217,"flixel.util.FlxStringUtil.getDomain","flixel/util/FlxStringUtil.hx",262,0x4e012e33)
            	HX_STACK_ARG(url,"url")
HXLINE( 263)		Int _hx_tmp = url.indexOf(HX_("://",da,2b,2c,00),null());
HXDLIN( 263)		HX_VARI( Int,urlStart) = (_hx_tmp + (int)3);
HXLINE( 264)		HX_VARI( Int,urlEnd) = url.indexOf(HX_("/",2f,00,00,00),urlStart);
HXLINE( 265)		HX_VARI( ::String,home) = url.substring(urlStart,urlEnd);
HXLINE( 266)		Int _hx_tmp1 = home.lastIndexOf(HX_(".",2e,00,00,00),null());
HXLINE( 267)		Int _hx_tmp2 = home.lastIndexOf(HX_(".",2e,00,00,00),(_hx_tmp1 - (int)1));
HXLINE( 268)		home = home.substring((_hx_tmp2 + (int)1),home.length);
HXLINE( 269)		::Array< ::String > _hx_tmp3 = home.split(HX_(":",3a,00,00,00));
HXDLIN( 269)		home = _hx_tmp3->__get((int)0);
HXLINE( 270)		if ((home == HX_("",00,00,00,00))) {
HXLINE( 270)			return HX_("local",6b,c9,f0,78);
            		}
            		else {
HXLINE( 270)			return home;
            		}
HXDLIN( 270)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,getDomain,return )

Bool FlxStringUtil_obj::sameClassName( ::Dynamic Obj1, ::Dynamic Obj2,hx::Null< Bool >  __o_Simple){
Bool Simple = __o_Simple.Default(true);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","sameClassName",0x3be7dc7a,"flixel.util.FlxStringUtil.sameClassName","flixel/util/FlxStringUtil.hx",283,0x4e012e33)
            	HX_STACK_ARG(Obj1,"Obj1")
            	HX_STACK_ARG(Obj2,"Obj2")
            	HX_STACK_ARG(Simple,"Simple")
HXLINE( 283)		HX_VAR( hx::Class,cl);
HXDLIN( 283)		Bool _hx_tmp = ::Std_obj::is(Obj1,hx::ClassOf< ::hx::Class >());
HXDLIN( 283)		if (_hx_tmp) {
HXLINE( 283)			cl = Obj1;
            		}
            		else {
HXLINE( 283)			cl = ::Type_obj::getClass(Obj1);
            		}
HXDLIN( 283)		HX_VARI( ::String,s) = ::Type_obj::getClassName(cl);
HXDLIN( 283)		Bool _hx_tmp1 = hx::IsNotNull( s );
HXDLIN( 283)		if (_hx_tmp1) {
HXLINE( 283)			s = ::StringTools_obj::replace(s,HX_("::",c0,32,00,00),HX_(".",2e,00,00,00));
HXDLIN( 283)			if (Simple) {
HXLINE( 283)				Int _hx_tmp2 = s.lastIndexOf(HX_(".",2e,00,00,00),null());
HXDLIN( 283)				s = s.substr((_hx_tmp2 + (int)1),null());
            			}
            		}
HXDLIN( 283)		::String _hx_tmp3 = s;
HXDLIN( 283)		HX_VAR_NAME( hx::Class,cl1,"cl");
HXDLIN( 283)		Bool _hx_tmp4 = ::Std_obj::is(Obj2,hx::ClassOf< ::hx::Class >());
HXDLIN( 283)		if (_hx_tmp4) {
HXLINE( 283)			cl1 = Obj2;
            		}
            		else {
HXLINE( 283)			cl1 = ::Type_obj::getClass(Obj2);
            		}
HXDLIN( 283)		HX_VARI_NAME( ::String,s1,"s") = ::Type_obj::getClassName(cl1);
HXDLIN( 283)		Bool _hx_tmp5 = hx::IsNotNull( s1 );
HXDLIN( 283)		if (_hx_tmp5) {
HXLINE( 283)			s1 = ::StringTools_obj::replace(s1,HX_("::",c0,32,00,00),HX_(".",2e,00,00,00));
HXDLIN( 283)			if (Simple) {
HXLINE( 283)				Int _hx_tmp6 = s1.lastIndexOf(HX_(".",2e,00,00,00),null());
HXDLIN( 283)				s1 = s1.substr((_hx_tmp6 + (int)1),null());
            			}
            		}
HXDLIN( 283)		return (_hx_tmp3 == s1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxStringUtil_obj,sameClassName,return )

::Array< Int > FlxStringUtil_obj::toIntArray(::String Data){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","toIntArray",0xa370d488,"flixel.util.FlxStringUtil.toIntArray","flixel/util/FlxStringUtil.hx",293,0x4e012e33)
            	HX_STACK_ARG(Data,"Data")
HXLINE( 294)		Bool _hx_tmp;
HXDLIN( 294)		Bool _hx_tmp1 = hx::IsNotNull( Data );
HXDLIN( 294)		if (_hx_tmp1) {
HXLINE( 294)			_hx_tmp = (Data != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 294)			_hx_tmp = false;
            		}
HXDLIN( 294)		if (_hx_tmp) {
HXLINE( 296)			HX_VARI( ::Array< ::String >,strArray) = Data.split(HX_(",",2c,00,00,00));
HXLINE( 297)			HX_VARI( ::Array< Int >,iArray) = ::Array_obj< Int >::__new();
HXLINE( 298)			{
HXLINE( 298)				HX_VARI( Int,_g) = (int)0;
HXDLIN( 298)				while((_g < strArray->length)){
HXLINE( 298)					HX_VARI( ::String,str) = strArray->__get(_g);
HXDLIN( 298)					++_g;
HXLINE( 300)					 ::Dynamic _hx_tmp2 = ::Std_obj::parseInt(str);
HXDLIN( 300)					iArray->push(_hx_tmp2);
            				}
            			}
HXLINE( 302)			return iArray;
            		}
HXLINE( 304)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,toIntArray,return )

::Array< Float > FlxStringUtil_obj::toFloatArray(::String Data){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","toFloatArray",0xcff15c3b,"flixel.util.FlxStringUtil.toFloatArray","flixel/util/FlxStringUtil.hx",314,0x4e012e33)
            	HX_STACK_ARG(Data,"Data")
HXLINE( 315)		Bool _hx_tmp;
HXDLIN( 315)		Bool _hx_tmp1 = hx::IsNotNull( Data );
HXDLIN( 315)		if (_hx_tmp1) {
HXLINE( 315)			_hx_tmp = (Data != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 315)			_hx_tmp = false;
            		}
HXDLIN( 315)		if (_hx_tmp) {
HXLINE( 317)			HX_VARI( ::Array< ::String >,strArray) = Data.split(HX_(",",2c,00,00,00));
HXLINE( 318)			HX_VARI( ::Array< Float >,fArray) = ::Array_obj< Float >::__new();
HXLINE( 319)			{
HXLINE( 319)				HX_VARI( Int,_g) = (int)0;
HXDLIN( 319)				while((_g < strArray->length)){
HXLINE( 319)					HX_VARI( ::String,str) = strArray->__get(_g);
HXDLIN( 319)					++_g;
HXLINE( 321)					Float _hx_tmp2 = ::Std_obj::parseFloat(str);
HXDLIN( 321)					fArray->push(_hx_tmp2);
            				}
            			}
HXLINE( 323)			return fArray;
            		}
HXLINE( 325)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,toFloatArray,return )

::String FlxStringUtil_obj::arrayToCSV(::Array< Int > Data,Int Width,hx::Null< Bool >  __o_Invert){
Bool Invert = __o_Invert.Default(false);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","arrayToCSV",0xd181e275,"flixel.util.FlxStringUtil.arrayToCSV","flixel/util/FlxStringUtil.hx",337,0x4e012e33)
            	HX_STACK_ARG(Data,"Data")
            	HX_STACK_ARG(Width,"Width")
            	HX_STACK_ARG(Invert,"Invert")
HXLINE( 338)		HX_VARI( Int,row) = (int)0;
HXLINE( 339)		HX_VAR( Int,column);
HXLINE( 340)		HX_VARI( ::String,csv) = HX_("",00,00,00,00);
HXLINE( 341)		Float _hx_tmp = ((Float)Data->length / (Float)Width);
HXDLIN( 341)		HX_VARI( Int,height) = ::Std_obj::_hx_int(_hx_tmp);
HXLINE( 342)		HX_VAR( Int,index);
HXLINE( 343)		HX_VARI( Int,offset) = (int)0;
HXLINE( 345)		while((row < height)){
HXLINE( 347)			column = (int)0;
HXLINE( 349)			while((column < Width)){
HXLINE( 351)				index = Data->__get(offset);
HXLINE( 353)				if (Invert) {
HXLINE( 355)					Bool _hx_tmp1 = (index == (int)0);
HXDLIN( 355)					if (_hx_tmp1) {
HXLINE( 357)						index = (int)1;
            					}
            					else {
HXLINE( 359)						Bool _hx_tmp2 = (index == (int)1);
HXDLIN( 359)						if (_hx_tmp2) {
HXLINE( 361)							index = (int)0;
            						}
            					}
            				}
HXLINE( 365)				if ((column == (int)0)) {
HXLINE( 367)					if ((row == (int)0)) {
HXLINE( 369)						hx::AddEq(csv,index);
            					}
            					else {
HXLINE( 373)						hx::AddEq(csv,(HX_("\n",0a,00,00,00) + index));
            					}
            				}
            				else {
HXLINE( 378)					hx::AddEq(csv,(HX_(", ",74,26,00,00) + index));
            				}
HXLINE( 381)				++column;
HXLINE( 382)				++offset;
            			}
HXLINE( 385)			++row;
            		}
HXLINE( 388)		return csv;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxStringUtil_obj,arrayToCSV,return )

::String FlxStringUtil_obj::bitmapToCSV( ::openfl::_legacy::display::BitmapData Bitmap,hx::Null< Bool >  __o_Invert,hx::Null< Int >  __o_Scale,::Array< Int > ColorMap){
Bool Invert = __o_Invert.Default(false);
Int Scale = __o_Scale.Default(1);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","bitmapToCSV",0x6fd72f79,"flixel.util.FlxStringUtil.bitmapToCSV","flixel/util/FlxStringUtil.hx",402,0x4e012e33)
            	HX_STACK_ARG(Bitmap,"Bitmap")
            	HX_STACK_ARG(Invert,"Invert")
            	HX_STACK_ARG(Scale,"Scale")
            	HX_STACK_ARG(ColorMap,"ColorMap")
HXLINE( 403)		Bool _hx_tmp = (Scale < (int)1);
HXDLIN( 403)		if (_hx_tmp) {
HXLINE( 405)			Scale = (int)1;
            		}
HXLINE( 409)		if ((Scale > (int)1)) {
HXLINE( 411)			HX_VARI(  ::openfl::_legacy::display::BitmapData,bd) = Bitmap;
HXLINE( 412)			Int _hx_tmp1 = Bitmap->get_width();
HXDLIN( 412)			Int _hx_tmp2 = (_hx_tmp1 * Scale);
HXDLIN( 412)			Int _hx_tmp3 = Bitmap->get_height();
HXDLIN( 412)			Bitmap =  ::openfl::_legacy::display::BitmapData_obj::__new(_hx_tmp2,(_hx_tmp3 * Scale),null(),null(),null());
HXLINE( 415)			HX_VARI( Int,bdW) = bd->get_width();
HXLINE( 416)			HX_VARI( Int,bdH) = bd->get_height();
HXLINE( 417)			HX_VARI( Int,pCol) = (int)0;
HXLINE( 419)			{
HXLINE( 419)				HX_VARI( Int,_g1) = (int)0;
HXDLIN( 419)				while((_g1 < bdW)){
HXLINE( 419)					HX_VARI( Int,i) = _g1++;
HXLINE( 421)					{
HXLINE( 421)						HX_VARI( Int,_g3) = (int)0;
HXDLIN( 421)						while((_g3 < bdH)){
HXLINE( 421)							HX_VARI( Int,j) = _g3++;
HXLINE( 423)							pCol = bd->getPixel(i,j);
HXLINE( 425)							{
HXLINE( 425)								HX_VARI( Int,_g5) = (int)0;
HXDLIN( 425)								HX_VARI( Int,_g4) = Scale;
HXDLIN( 425)								while((_g5 < _g4)){
HXLINE( 425)									HX_VARI( Int,k) = _g5++;
HXLINE( 427)									{
HXLINE( 427)										HX_VARI( Int,_g7) = (int)0;
HXDLIN( 427)										HX_VARI( Int,_g6) = Scale;
HXDLIN( 427)										while((_g7 < _g6)){
HXLINE( 427)											HX_VARI( Int,m) = _g7++;
HXLINE( 429)											Bitmap->setPixel(((i * Scale) + k),((j * Scale) + m),pCol);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 441)		Bool _hx_tmp4 = hx::IsNotNull( ColorMap );
HXDLIN( 441)		if (_hx_tmp4) {
HXLINE( 443)			HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 443)			HX_VARI( Int,_g) = ColorMap->length;
HXDLIN( 443)			while((_g11 < _g)){
HXLINE( 443)				HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE( 445)				ColorMap[i1] = ((int)ColorMap->__get(i1) & (int)(int)16777215);
            			}
            		}
HXLINE( 450)		HX_VARI( Int,row) = (int)0;
HXLINE( 451)		HX_VAR( Int,column);
HXLINE( 452)		HX_VAR( Int,pixel);
HXLINE( 453)		HX_VARI( ::String,csv) = HX_("",00,00,00,00);
HXLINE( 454)		HX_VARI( Int,bitmapWidth) = Bitmap->get_width();
HXLINE( 455)		HX_VARI( Int,bitmapHeight) = Bitmap->get_height();
HXLINE( 457)		while((row < bitmapHeight)){
HXLINE( 459)			column = (int)0;
HXLINE( 461)			while((column < bitmapWidth)){
HXLINE( 464)				pixel = Bitmap->getPixel(column,row);
HXLINE( 466)				Bool _hx_tmp5 = hx::IsNotNull( ColorMap );
HXDLIN( 466)				if (_hx_tmp5) {
HXLINE( 468)					pixel = ColorMap->indexOf(pixel,null());
            				}
            				else {
HXLINE( 470)					Bool _hx_tmp6;
HXDLIN( 470)					Bool _hx_tmp7;
HXDLIN( 470)					if (Invert) {
HXLINE( 470)						_hx_tmp7 = (pixel > (int)0);
            					}
            					else {
HXLINE( 470)						_hx_tmp7 = false;
            					}
HXDLIN( 470)					if (!(_hx_tmp7)) {
HXLINE( 470)						if (!(Invert)) {
HXLINE( 470)							_hx_tmp6 = (pixel == (int)0);
            						}
            						else {
HXLINE( 470)							_hx_tmp6 = false;
            						}
            					}
            					else {
HXLINE( 470)						_hx_tmp6 = true;
            					}
HXDLIN( 470)					if (_hx_tmp6) {
HXLINE( 472)						pixel = (int)1;
            					}
            					else {
HXLINE( 476)						pixel = (int)0;
            					}
            				}
HXLINE( 480)				if ((column == (int)0)) {
HXLINE( 482)					if ((row == (int)0)) {
HXLINE( 484)						hx::AddEq(csv,pixel);
            					}
            					else {
HXLINE( 488)						hx::AddEq(csv,(HX_("\n",0a,00,00,00) + pixel));
            					}
            				}
            				else {
HXLINE( 493)					hx::AddEq(csv,(HX_(", ",74,26,00,00) + pixel));
            				}
HXLINE( 496)				++column;
            			}
HXLINE( 499)			++row;
            		}
HXLINE( 502)		return csv;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxStringUtil_obj,bitmapToCSV,return )

::String FlxStringUtil_obj::imageToCSV( ::Dynamic ImageFile,hx::Null< Bool >  __o_Invert,hx::Null< Int >  __o_Scale,::Array< Int > ColorMap){
Bool Invert = __o_Invert.Default(false);
Int Scale = __o_Scale.Default(1);
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","imageToCSV",0xe3229173,"flixel.util.FlxStringUtil.imageToCSV","flixel/util/FlxStringUtil.hx",516,0x4e012e33)
            	HX_STACK_ARG(ImageFile,"ImageFile")
            	HX_STACK_ARG(Invert,"Invert")
            	HX_STACK_ARG(Scale,"Scale")
            	HX_STACK_ARG(ColorMap,"ColorMap")
HXLINE( 517)		HX_VAR(  ::openfl::_legacy::display::BitmapData,tempBitmapData);
HXLINE( 519)		Bool _hx_tmp = ::Std_obj::is(ImageFile,hx::ClassOf< ::String >());
HXDLIN( 519)		if (_hx_tmp) {
HXLINE( 521)			HX_VARI( ::String,id) = ( (::String)(ImageFile) );
HXDLIN( 521)			Bool _hx_tmp1 = ::openfl::_legacy::Assets_obj::exists(id,null());
HXDLIN( 521)			if (_hx_tmp1) {
HXLINE( 521)				tempBitmapData = ::openfl::_legacy::Assets_obj::getBitmapData(id,false);
            			}
            			else {
HXLINE( 521)				tempBitmapData = null();
            			}
            		}
            		else {
HXLINE( 525)			tempBitmapData = ( ( ::openfl::_legacy::display::BitmapData)(::Type_obj::createInstance(ImageFile,::cpp::VirtualArray_obj::__new(0))->__Field(HX_("bitmapData",b9,b5,c0,33),hx::paccDynamic)) );
            		}
HXLINE( 528)		return ::flixel::util::FlxStringUtil_obj::bitmapToCSV(tempBitmapData,Invert,Scale,ColorMap);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxStringUtil_obj,imageToCSV,return )

::String FlxStringUtil_obj::getDebugString(::Array< ::Dynamic> LabelValuePairs){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","getDebugString",0x47d891d1,"flixel.util.FlxStringUtil.getDebugString","flixel/util/FlxStringUtil.hx",538,0x4e012e33)
            	HX_STACK_ARG(LabelValuePairs,"LabelValuePairs")
HXLINE( 539)		HX_VARI( ::String,output) = HX_("(",28,00,00,00);
HXLINE( 540)		{
HXLINE( 540)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 540)			while((_g < LabelValuePairs->length)){
HXLINE( 540)				HX_VARI(  ::flixel::util::LabelValuePair,pair) = LabelValuePairs->__get(_g).StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 540)				++_g;
HXLINE( 542)				hx::AddEq(output,(pair->label + HX_(": ",a6,32,00,00)));
HXLINE( 543)				HX_VARI(  ::Dynamic,value) = pair->value;
HXLINE( 544)				Bool _hx_tmp = ::Std_obj::is(value,hx::ClassOf< ::Float >());
HXDLIN( 544)				if (_hx_tmp) {
HXLINE( 546)					value = ::flixel::math::FlxMath_obj::roundDecimal(( (Float)(value) ),::flixel::FlxG_obj::debugger->precision);
            				}
HXLINE( 548)				::String _hx_tmp1 = ::Std_obj::string(value);
HXDLIN( 548)				hx::AddEq(output,(_hx_tmp1 + HX_(" | ",44,b4,18,00)));
HXLINE( 549)				::flixel::util::LabelValuePair_obj::_pool->put(pair);
            			}
            		}
HXLINE( 552)		Int _hx_tmp2 = (output.length - (int)2);
HXDLIN( 552)		::String _hx_tmp3 = output.substr((int)0,_hx_tmp2);
HXDLIN( 552)		output = ::StringTools_obj::trim(_hx_tmp3);
HXLINE( 553)		return (output + HX_(")",29,00,00,00));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,getDebugString,return )

Bool FlxStringUtil_obj::contains(::String s,::String str){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","contains",0x45000522,"flixel.util.FlxStringUtil.contains","flixel/util/FlxStringUtil.hx",558,0x4e012e33)
            	HX_STACK_ARG(s,"s")
            	HX_STACK_ARG(str,"str")
HXLINE( 558)		Int _hx_tmp = s.indexOf(str,null());
HXDLIN( 558)		return (_hx_tmp != (int)-1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxStringUtil_obj,contains,return )

::String FlxStringUtil_obj::remove(::String s,::String sub){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","remove",0xf6fd7087,"flixel.util.FlxStringUtil.remove","flixel/util/FlxStringUtil.hx",566,0x4e012e33)
            	HX_STACK_ARG(s,"s")
            	HX_STACK_ARG(sub,"sub")
HXLINE( 566)		return ::StringTools_obj::replace(s,sub,HX_("",00,00,00,00));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxStringUtil_obj,remove,return )

::String FlxStringUtil_obj::insert(::String s,Int pos,::String insertion){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","insert",0x9052177c,"flixel.util.FlxStringUtil.insert","flixel/util/FlxStringUtil.hx",574,0x4e012e33)
            	HX_STACK_ARG(s,"s")
            	HX_STACK_ARG(pos,"pos")
            	HX_STACK_ARG(insertion,"insertion")
HXLINE( 574)		::String _hx_tmp = s.substring((int)0,pos);
HXDLIN( 574)		::String _hx_tmp1 = (_hx_tmp + insertion);
HXDLIN( 574)		::String _hx_tmp2 = s.substr(pos,null());
HXDLIN( 574)		return (_hx_tmp1 + _hx_tmp2);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxStringUtil_obj,insert,return )

::Array< ::String > FlxStringUtil_obj::sortAlphabetically(::Array< ::String > list){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		Int _hx_run(::String a,::String b){
            			HX_STACK_FRAME("flixel.util.FlxStringUtil","sortAlphabetically",0xf5002ac6,"flixel.util.FlxStringUtil.sortAlphabetically","flixel/util/FlxStringUtil.hx",580,0x4e012e33)
            			HX_STACK_ARG(a,"a")
            			HX_STACK_ARG(b,"b")
HXLINE( 581)			a = a.toLowerCase();
HXLINE( 582)			b = b.toLowerCase();
HXLINE( 583)			if ((a < b)) {
HXLINE( 583)				return (int)-1;
            			}
HXLINE( 584)			if ((a > b)) {
HXLINE( 584)				return (int)1;
            			}
HXLINE( 585)			return (int)0;
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_STACK_FRAME("flixel.util.FlxStringUtil","sortAlphabetically",0xf5002ac6,"flixel.util.FlxStringUtil.sortAlphabetically","flixel/util/FlxStringUtil.hx",578,0x4e012e33)
            	HX_STACK_ARG(list,"list")
HXLINE( 579)		list->sort( ::Dynamic(new _hx_Closure_0()));
HXLINE( 587)		return list;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,sortAlphabetically,return )

Bool FlxStringUtil_obj::isNullOrEmpty(::String s){
            	HX_STACK_FRAME("flixel.util.FlxStringUtil","isNullOrEmpty",0x99779cf6,"flixel.util.FlxStringUtil.isNullOrEmpty","flixel/util/FlxStringUtil.hx",595,0x4e012e33)
            	HX_STACK_ARG(s,"s")
HXLINE( 595)		Bool _hx_tmp = hx::IsNotNull( s );
HXDLIN( 595)		if (_hx_tmp) {
HXLINE( 595)			return (s.length == (int)0);
            		}
            		else {
HXLINE( 595)			return true;
            		}
HXDLIN( 595)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxStringUtil_obj,isNullOrEmpty,return )


FlxStringUtil_obj::FlxStringUtil_obj()
{
}

bool FlxStringUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"remove") ) { outValue = remove_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"insert") ) { outValue = insert_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"contains") ) { outValue = contains_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"getDomain") ) { outValue = getDomain_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"formatTime") ) { outValue = formatTime_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"htmlFormat") ) { outValue = htmlFormat_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toIntArray") ) { outValue = toIntArray_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"arrayToCSV") ) { outValue = arrayToCSV_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"imageToCSV") ) { outValue = imageToCSV_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"formatTicks") ) { outValue = formatTicks_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"formatArray") ) { outValue = formatArray_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"formatMoney") ) { outValue = formatMoney_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"formatBytes") ) { outValue = formatBytes_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"bitmapToCSV") ) { outValue = bitmapToCSV_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"filterDigits") ) { outValue = filterDigits_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toFloatArray") ) { outValue = toFloatArray_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"sameClassName") ) { outValue = sameClassName_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isNullOrEmpty") ) { outValue = isNullOrEmpty_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getDebugString") ) { outValue = getDebugString_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"formatStringMap") ) { outValue = formatStringMap_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"sortAlphabetically") ) { outValue = sortAlphabetically_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxStringUtil_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *FlxStringUtil_obj_sStaticStorageInfo = 0;
#endif

static void FlxStringUtil_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxStringUtil_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxStringUtil_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxStringUtil_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxStringUtil_obj::__mClass;

static ::String FlxStringUtil_obj_sStaticFields[] = {
	HX_HCSTRING("formatTicks","\xbf","\x87","\x47","\xc9"),
	HX_HCSTRING("formatTime","\xe4","\xee","\x61","\x0c"),
	HX_HCSTRING("formatArray","\xe2","\xc6","\xa8","\xde"),
	HX_HCSTRING("formatStringMap","\x14","\x64","\x33","\x33"),
	HX_HCSTRING("formatMoney","\x89","\x13","\x79","\xc5"),
	HX_HCSTRING("formatBytes","\xb4","\x61","\xb1","\x76"),
	HX_HCSTRING("filterDigits","\xfe","\x37","\x80","\xc1"),
	HX_HCSTRING("htmlFormat","\x02","\xfb","\x4f","\xcb"),
	HX_HCSTRING("getDomain","\x7a","\x3a","\xd7","\xa9"),
	HX_HCSTRING("sameClassName","\x5d","\x52","\x26","\x79"),
	HX_HCSTRING("toIntArray","\xc5","\x22","\x29","\xe0"),
	HX_HCSTRING("toFloatArray","\xb8","\x73","\x07","\xe6"),
	HX_HCSTRING("arrayToCSV","\xb2","\x30","\x3a","\x0e"),
	HX_HCSTRING("bitmapToCSV","\x9c","\x56","\x63","\x54"),
	HX_HCSTRING("imageToCSV","\xb0","\xdf","\xda","\x1f"),
	HX_HCSTRING("getDebugString","\x8e","\x42","\x41","\xa1"),
	HX_HCSTRING("contains","\x1f","\x5a","\x7b","\x2c"),
	HX_HCSTRING("remove","\x44","\x9c","\x88","\x04"),
	HX_HCSTRING("insert","\x39","\x43","\xdd","\x9d"),
	HX_HCSTRING("sortAlphabetically","\x03","\x7e","\x3c","\x7b"),
	HX_HCSTRING("isNullOrEmpty","\xd9","\x12","\xb6","\xd6"),
	::String(null())
};

void FlxStringUtil_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.util.FlxStringUtil","\xcb","\x21","\xbd","\x03");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxStringUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxStringUtil_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxStringUtil_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxStringUtil_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxStringUtil_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxStringUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxStringUtil_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace util
