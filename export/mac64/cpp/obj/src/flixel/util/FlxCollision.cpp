// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTileblock
#include <flixel/tile/FlxTileblock.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataPool
#include <flixel/util/FlxBitmapDataPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxCollision
#include <flixel/util/FlxCollision.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_ByteArray
#include <openfl/_legacy/utils/ByteArray.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_IDataInput
#include <openfl/_legacy/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_IDataOutput
#include <openfl/_legacy/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_openfl__legacy_utils_IMemoryRange
#include <openfl/_legacy/utils/IMemoryRange.h>
#endif

namespace flixel{
namespace util{

void FlxCollision_obj::__construct() { }

Dynamic FlxCollision_obj::__CreateEmpty() { return new FlxCollision_obj; }

hx::ObjectPtr< FlxCollision_obj > FlxCollision_obj::__new()
{
	hx::ObjectPtr< FlxCollision_obj > _hx_result = new FlxCollision_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic FlxCollision_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxCollision_obj > _hx_result = new FlxCollision_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::openfl::_legacy::geom::Point FlxCollision_obj::pointA;

 ::openfl::_legacy::geom::Point FlxCollision_obj::pointB;

 ::openfl::_legacy::geom::Point FlxCollision_obj::centerA;

 ::openfl::_legacy::geom::Point FlxCollision_obj::centerB;

 ::openfl::_legacy::geom::Matrix FlxCollision_obj::matrixA;

 ::openfl::_legacy::geom::Matrix FlxCollision_obj::matrixB;

 ::openfl::_legacy::geom::Matrix FlxCollision_obj::testMatrix;

 ::openfl::_legacy::geom::Rectangle FlxCollision_obj::boundsA;

 ::openfl::_legacy::geom::Rectangle FlxCollision_obj::boundsB;

Bool FlxCollision_obj::pixelPerfectCheck( ::flixel::FlxSprite Contact, ::flixel::FlxSprite Target,hx::Null< Int >  __o_AlphaTolerance, ::flixel::FlxCamera Camera){
Int AlphaTolerance = __o_AlphaTolerance.Default(1);
            	HX_STACK_FRAME("flixel.util.FlxCollision","pixelPerfectCheck",0xcaf595cd,"flixel.util.FlxCollision.pixelPerfectCheck","flixel/util/FlxCollision.hx",45,0x8c8a7b84)
            	HX_STACK_ARG(Contact,"Contact")
            	HX_STACK_ARG(Target,"Target")
            	HX_STACK_ARG(AlphaTolerance,"AlphaTolerance")
            	HX_STACK_ARG(Camera,"Camera")
HXLINE(  47)		HX_VAR( Bool,considerRotation);
HXDLIN(  47)		if ((Contact->angle == (int)0)) {
HXLINE(  47)			considerRotation = (Target->angle != (int)0);
            		}
            		else {
HXLINE(  47)			considerRotation = true;
            		}
HXLINE(  49)		Bool _hx_tmp = hx::IsNotNull( Camera );
HXDLIN(  49)		if (_hx_tmp) {
HXLINE(  49)			Camera = Camera;
            		}
            		else {
HXLINE(  49)			Camera = ::flixel::FlxG_obj::camera;
            		}
HXLINE(  51)		Float _hx_tmp1 = Contact->x;
HXDLIN(  51)		Float _hx_tmp2 = (Camera->scroll->x * Contact->scrollFactor->x);
HXDLIN(  51)		Int _hx_tmp3 = ::Std_obj::_hx_int(_hx_tmp2);
HXDLIN(  51)		::flixel::util::FlxCollision_obj::pointA->x = ((_hx_tmp1 - _hx_tmp3) - Contact->offset->x);
HXLINE(  52)		Float _hx_tmp4 = Contact->y;
HXDLIN(  52)		Float _hx_tmp5 = (Camera->scroll->y * Contact->scrollFactor->y);
HXDLIN(  52)		Int _hx_tmp6 = ::Std_obj::_hx_int(_hx_tmp5);
HXDLIN(  52)		::flixel::util::FlxCollision_obj::pointA->y = ((_hx_tmp4 - _hx_tmp6) - Contact->offset->y);
HXLINE(  54)		Float _hx_tmp7 = Target->x;
HXDLIN(  54)		Float _hx_tmp8 = (Camera->scroll->x * Target->scrollFactor->x);
HXDLIN(  54)		Int _hx_tmp9 = ::Std_obj::_hx_int(_hx_tmp8);
HXDLIN(  54)		::flixel::util::FlxCollision_obj::pointB->x = ((_hx_tmp7 - _hx_tmp9) - Target->offset->x);
HXLINE(  55)		Float _hx_tmp10 = Target->y;
HXDLIN(  55)		Float _hx_tmp11 = (Camera->scroll->y * Target->scrollFactor->y);
HXDLIN(  55)		Int _hx_tmp12 = ::Std_obj::_hx_int(_hx_tmp11);
HXDLIN(  55)		::flixel::util::FlxCollision_obj::pointB->y = ((_hx_tmp10 - _hx_tmp12) - Target->offset->y);
HXLINE(  57)		if (considerRotation) {
HXLINE(  60)			{
HXLINE(  60)				HX_VARI(  ::flixel::math::FlxPoint,_this) = Contact->origin;
HXDLIN(  60)				HX_VARI(  ::openfl::_legacy::geom::Point,FlashPoint) = ::flixel::util::FlxCollision_obj::centerA;
HXDLIN(  60)				Bool _hx_tmp13 = hx::IsNull( FlashPoint );
HXDLIN(  60)				if (_hx_tmp13) {
HXLINE(  60)					FlashPoint =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
            				}
HXDLIN(  60)				FlashPoint->x = _this->x;
HXDLIN(  60)				FlashPoint->y = _this->y;
            			}
HXLINE(  61)			{
HXLINE(  61)				HX_VARI_NAME(  ::flixel::math::FlxPoint,_this1,"_this") = Target->origin;
HXDLIN(  61)				HX_VARI_NAME(  ::openfl::_legacy::geom::Point,FlashPoint1,"FlashPoint") = ::flixel::util::FlxCollision_obj::centerB;
HXDLIN(  61)				Bool _hx_tmp14 = hx::IsNull( FlashPoint1 );
HXDLIN(  61)				if (_hx_tmp14) {
HXLINE(  61)					FlashPoint1 =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
            				}
HXDLIN(  61)				FlashPoint1->x = _this1->x;
HXDLIN(  61)				FlashPoint1->y = _this1->y;
            			}
HXLINE(  64)			Float _hx_tmp15 = (::flixel::util::FlxCollision_obj::pointA->x + ::flixel::util::FlxCollision_obj::centerA->x);
HXDLIN(  64)			Float _hx_tmp16 = ::flixel::util::FlxCollision_obj::centerA->get_length();
HXDLIN(  64)			::flixel::util::FlxCollision_obj::boundsA->x = (_hx_tmp15 - _hx_tmp16);
HXLINE(  65)			Float _hx_tmp17 = (::flixel::util::FlxCollision_obj::pointA->y + ::flixel::util::FlxCollision_obj::centerA->y);
HXDLIN(  65)			Float _hx_tmp18 = ::flixel::util::FlxCollision_obj::centerA->get_length();
HXDLIN(  65)			::flixel::util::FlxCollision_obj::boundsA->y = (_hx_tmp17 - _hx_tmp18);
HXLINE(  66)			Float _hx_tmp19 = ::flixel::util::FlxCollision_obj::centerA->get_length();
HXDLIN(  66)			::flixel::util::FlxCollision_obj::boundsA->width = (_hx_tmp19 * (int)2);
HXLINE(  67)			::flixel::util::FlxCollision_obj::boundsA->height = ::flixel::util::FlxCollision_obj::boundsA->width;
HXLINE(  69)			Float _hx_tmp20 = (::flixel::util::FlxCollision_obj::pointB->x + ::flixel::util::FlxCollision_obj::centerB->x);
HXDLIN(  69)			Float _hx_tmp21 = ::flixel::util::FlxCollision_obj::centerB->get_length();
HXDLIN(  69)			::flixel::util::FlxCollision_obj::boundsB->x = (_hx_tmp20 - _hx_tmp21);
HXLINE(  70)			Float _hx_tmp22 = (::flixel::util::FlxCollision_obj::pointB->y + ::flixel::util::FlxCollision_obj::centerB->y);
HXDLIN(  70)			Float _hx_tmp23 = ::flixel::util::FlxCollision_obj::centerB->get_length();
HXDLIN(  70)			::flixel::util::FlxCollision_obj::boundsB->y = (_hx_tmp22 - _hx_tmp23);
HXLINE(  71)			Float _hx_tmp24 = ::flixel::util::FlxCollision_obj::centerB->get_length();
HXDLIN(  71)			::flixel::util::FlxCollision_obj::boundsB->width = (_hx_tmp24 * (int)2);
HXLINE(  72)			::flixel::util::FlxCollision_obj::boundsB->height = ::flixel::util::FlxCollision_obj::boundsB->width;
            		}
            		else {
HXLINE(  76)			::flixel::util::FlxCollision_obj::boundsA->x = ::flixel::util::FlxCollision_obj::pointA->x;
HXLINE(  77)			::flixel::util::FlxCollision_obj::boundsA->y = ::flixel::util::FlxCollision_obj::pointA->y;
HXLINE(  78)			::flixel::util::FlxCollision_obj::boundsA->width = Contact->frameWidth;
HXLINE(  79)			::flixel::util::FlxCollision_obj::boundsA->height = Contact->frameHeight;
HXLINE(  81)			::flixel::util::FlxCollision_obj::boundsB->x = ::flixel::util::FlxCollision_obj::pointB->x;
HXLINE(  82)			::flixel::util::FlxCollision_obj::boundsB->y = ::flixel::util::FlxCollision_obj::pointB->y;
HXLINE(  83)			::flixel::util::FlxCollision_obj::boundsB->width = Target->frameWidth;
HXLINE(  84)			::flixel::util::FlxCollision_obj::boundsB->height = Target->frameHeight;
            		}
HXLINE(  87)		HX_VARI(  ::openfl::_legacy::geom::Rectangle,intersect) = ::flixel::util::FlxCollision_obj::boundsA->intersection(::flixel::util::FlxCollision_obj::boundsB);
HXLINE(  89)		Bool _hx_tmp25;
HXDLIN(  89)		Bool _hx_tmp26;
HXDLIN(  89)		Bool _hx_tmp27 = !(intersect->isEmpty());
HXDLIN(  89)		if (_hx_tmp27) {
HXLINE(  89)			_hx_tmp26 = (intersect->width < (int)1);
            		}
            		else {
HXLINE(  89)			_hx_tmp26 = true;
            		}
HXDLIN(  89)		if (!(_hx_tmp26)) {
HXLINE(  89)			_hx_tmp25 = (intersect->height < (int)1);
            		}
            		else {
HXLINE(  89)			_hx_tmp25 = true;
            		}
HXDLIN(  89)		if (_hx_tmp25) {
HXLINE(  91)			return false;
            		}
HXLINE(  95)		::flixel::util::FlxCollision_obj::matrixA->identity();
HXLINE(  96)		::flixel::util::FlxCollision_obj::matrixA->translate(-((intersect->x - ::flixel::util::FlxCollision_obj::boundsA->x)),-((intersect->y - ::flixel::util::FlxCollision_obj::boundsA->y)));
HXLINE(  98)		::flixel::util::FlxCollision_obj::matrixB->identity();
HXLINE(  99)		::flixel::util::FlxCollision_obj::matrixB->translate(-((intersect->x - ::flixel::util::FlxCollision_obj::boundsB->x)),-((intersect->y - ::flixel::util::FlxCollision_obj::boundsB->y)));
HXLINE( 101)		Bool _hx_tmp28 = ::flixel::FlxG_obj::renderTile;
HXDLIN( 101)		if (_hx_tmp28) {
HXLINE( 103)			Contact->drawFrame(null());
HXLINE( 104)			Target->drawFrame(null());
            		}
HXLINE( 107)		HX_VARI(  ::openfl::_legacy::display::BitmapData,testA) = Contact->framePixels;
HXLINE( 108)		HX_VARI(  ::openfl::_legacy::display::BitmapData,testB) = Target->framePixels;
HXLINE( 110)		HX_VARI( Int,overlapWidth) = ::Std_obj::_hx_int(intersect->width);
HXLINE( 111)		HX_VARI( Int,overlapHeight) = ::Std_obj::_hx_int(intersect->height);
HXLINE( 114)		if (considerRotation) {
HXLINE( 116)			::flixel::util::FlxCollision_obj::testMatrix->identity();
HXLINE( 119)			::flixel::util::FlxCollision_obj::testMatrix->translate(-(Contact->origin->x),-(Contact->origin->y));
HXLINE( 122)			Float _hx_tmp29 = (Contact->angle * ((Float)::Math_obj::PI / (Float)(int)180));
HXDLIN( 122)			::flixel::util::FlxCollision_obj::testMatrix->rotate(_hx_tmp29);
HXLINE( 125)			Float _hx_tmp30 = ((Float)::flixel::util::FlxCollision_obj::boundsA->width / (Float)(int)2);
HXDLIN( 125)			Float _hx_tmp31 = ((Float)::flixel::util::FlxCollision_obj::boundsA->height / (Float)(int)2);
HXDLIN( 125)			::flixel::util::FlxCollision_obj::testMatrix->translate(_hx_tmp30,_hx_tmp31);
HXLINE( 128)			Int _hx_tmp32 = ::Math_obj::floor(::flixel::util::FlxCollision_obj::boundsA->width);
HXDLIN( 128)			Int _hx_tmp33 = ::Math_obj::floor(::flixel::util::FlxCollision_obj::boundsA->height);
HXDLIN( 128)			HX_VARI(  ::openfl::_legacy::display::BitmapData,testA2) = ::flixel::util::FlxBitmapDataPool_obj::get(_hx_tmp32,_hx_tmp33,true,(int)0,false);
HXLINE( 131)			testA2->draw(testA,::flixel::util::FlxCollision_obj::testMatrix,null(),null(),null(),false);
HXLINE( 132)			testA = testA2;
HXLINE( 135)			::flixel::util::FlxCollision_obj::testMatrix->identity();
HXLINE( 136)			::flixel::util::FlxCollision_obj::testMatrix->translate(-(Target->origin->x),-(Target->origin->y));
HXLINE( 137)			Float _hx_tmp34 = (Target->angle * ((Float)::Math_obj::PI / (Float)(int)180));
HXDLIN( 137)			::flixel::util::FlxCollision_obj::testMatrix->rotate(_hx_tmp34);
HXLINE( 138)			Float _hx_tmp35 = ((Float)::flixel::util::FlxCollision_obj::boundsB->width / (Float)(int)2);
HXDLIN( 138)			Float _hx_tmp36 = ((Float)::flixel::util::FlxCollision_obj::boundsB->height / (Float)(int)2);
HXDLIN( 138)			::flixel::util::FlxCollision_obj::testMatrix->translate(_hx_tmp35,_hx_tmp36);
HXLINE( 140)			Int _hx_tmp37 = ::Math_obj::floor(::flixel::util::FlxCollision_obj::boundsB->width);
HXDLIN( 140)			Int _hx_tmp38 = ::Math_obj::floor(::flixel::util::FlxCollision_obj::boundsB->height);
HXDLIN( 140)			HX_VARI(  ::openfl::_legacy::display::BitmapData,testB2) = ::flixel::util::FlxBitmapDataPool_obj::get(_hx_tmp37,_hx_tmp38,true,(int)0,false);
HXLINE( 141)			testB2->draw(testB,::flixel::util::FlxCollision_obj::testMatrix,null(),null(),null(),false);
HXLINE( 142)			testB = testB2;
            		}
HXLINE( 145)		::flixel::util::FlxCollision_obj::boundsA->x = ::Std_obj::_hx_int(-(::flixel::util::FlxCollision_obj::matrixA->tx));
HXLINE( 146)		::flixel::util::FlxCollision_obj::boundsA->y = ::Std_obj::_hx_int(-(::flixel::util::FlxCollision_obj::matrixA->ty));
HXLINE( 147)		::flixel::util::FlxCollision_obj::boundsA->width = overlapWidth;
HXLINE( 148)		::flixel::util::FlxCollision_obj::boundsA->height = overlapHeight;
HXLINE( 150)		::flixel::util::FlxCollision_obj::boundsB->x = ::Std_obj::_hx_int(-(::flixel::util::FlxCollision_obj::matrixB->tx));
HXLINE( 151)		::flixel::util::FlxCollision_obj::boundsB->y = ::Std_obj::_hx_int(-(::flixel::util::FlxCollision_obj::matrixB->ty));
HXLINE( 152)		::flixel::util::FlxCollision_obj::boundsB->width = overlapWidth;
HXLINE( 153)		::flixel::util::FlxCollision_obj::boundsB->height = overlapHeight;
HXLINE( 155)		HX_VARI(  ::openfl::_legacy::utils::ByteArray,pixelsA) = testA->getPixels(::flixel::util::FlxCollision_obj::boundsA);
HXLINE( 156)		HX_VARI(  ::openfl::_legacy::utils::ByteArray,pixelsB) = testB->getPixels(::flixel::util::FlxCollision_obj::boundsB);
HXLINE( 158)		HX_VARI( Bool,hit) = false;
HXLINE( 161)		HX_VARI( Int,alphaA) = (int)0;
HXLINE( 162)		HX_VARI( Int,alphaB) = (int)0;
HXLINE( 163)		HX_VARI( Int,overlapPixels) = (overlapWidth * overlapHeight);
HXLINE( 164)		HX_VARI( Int,alphaIdx) = (int)0;
HXLINE( 167)		{
HXLINE( 167)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 167)			HX_VARI( Int,_g) = ::Math_obj::ceil(((Float)overlapPixels / (Float)(int)2));
HXDLIN( 167)			while((_g1 < _g)){
HXLINE( 167)				HX_VARI( Int,i) = _g1++;
HXLINE( 169)				alphaIdx = ((int)i << (int)(int)3);
HXLINE( 170)				pixelsA->position = (pixelsB->position = alphaIdx);
HXLINE( 171)				Bool _hx_tmp39 = (pixelsA->position < pixelsA->length);
HXDLIN( 171)				if (_hx_tmp39) {
HXLINE( 171)					Int pos = pixelsA->position++;
HXDLIN( 171)					alphaA = pixelsA->b->__get(pos);
            				}
            				else {
HXLINE( 171)					alphaA = pixelsA->_hx___throwEOFi();
            				}
HXLINE( 172)				Bool _hx_tmp40 = (pixelsB->position < pixelsB->length);
HXDLIN( 172)				if (_hx_tmp40) {
HXLINE( 172)					Int pos1 = pixelsB->position++;
HXDLIN( 172)					alphaB = pixelsB->b->__get(pos1);
            				}
            				else {
HXLINE( 172)					alphaB = pixelsB->_hx___throwEOFi();
            				}
HXLINE( 174)				Bool _hx_tmp41;
HXDLIN( 174)				if ((alphaA >= AlphaTolerance)) {
HXLINE( 174)					_hx_tmp41 = (alphaB >= AlphaTolerance);
            				}
            				else {
HXLINE( 174)					_hx_tmp41 = false;
            				}
HXDLIN( 174)				if (_hx_tmp41) {
HXLINE( 176)					hit = true;
HXLINE( 177)					goto _hx_goto_0;
            				}
            			}
            			_hx_goto_0:;
            		}
HXLINE( 181)		if (!(hit)) {
HXLINE( 184)			HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 184)			HX_VARI_NAME( Int,_g2,"_g") = ((int)overlapPixels >> (int)(int)1);
HXDLIN( 184)			while((_g11 < _g2)){
HXLINE( 184)				HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE( 186)				alphaIdx = (((int)i1 << (int)(int)3) + (int)4);
HXLINE( 187)				pixelsA->position = (pixelsB->position = alphaIdx);
HXLINE( 188)				Bool _hx_tmp42 = (pixelsA->position < pixelsA->length);
HXDLIN( 188)				if (_hx_tmp42) {
HXLINE( 188)					Int pos2 = pixelsA->position++;
HXDLIN( 188)					alphaA = pixelsA->b->__get(pos2);
            				}
            				else {
HXLINE( 188)					alphaA = pixelsA->_hx___throwEOFi();
            				}
HXLINE( 189)				Bool _hx_tmp43 = (pixelsB->position < pixelsB->length);
HXDLIN( 189)				if (_hx_tmp43) {
HXLINE( 189)					Int pos3 = pixelsB->position++;
HXDLIN( 189)					alphaB = pixelsB->b->__get(pos3);
            				}
            				else {
HXLINE( 189)					alphaB = pixelsB->_hx___throwEOFi();
            				}
HXLINE( 191)				Bool _hx_tmp44;
HXDLIN( 191)				if ((alphaA >= AlphaTolerance)) {
HXLINE( 191)					_hx_tmp44 = (alphaB >= AlphaTolerance);
            				}
            				else {
HXLINE( 191)					_hx_tmp44 = false;
            				}
HXDLIN( 191)				if (_hx_tmp44) {
HXLINE( 193)					hit = true;
HXLINE( 194)					goto _hx_goto_1;
            				}
            			}
            			_hx_goto_1:;
            		}
HXLINE( 199)		if (considerRotation) {
HXLINE( 201)			::flixel::util::FlxBitmapDataPool_obj::put(testA);
HXLINE( 202)			::flixel::util::FlxBitmapDataPool_obj::put(testB);
            		}
HXLINE( 205)		return hit;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxCollision_obj,pixelPerfectCheck,return )

Bool FlxCollision_obj::pixelPerfectPointCheck(Int PointX,Int PointY, ::flixel::FlxSprite Target,hx::Null< Int >  __o_AlphaTolerance){
Int AlphaTolerance = __o_AlphaTolerance.Default(1);
            	HX_STACK_FRAME("flixel.util.FlxCollision","pixelPerfectPointCheck",0x29896333,"flixel.util.FlxCollision.pixelPerfectPointCheck","flixel/util/FlxCollision.hx",218,0x8c8a7b84)
            	HX_STACK_ARG(PointX,"PointX")
            	HX_STACK_ARG(PointY,"PointY")
            	HX_STACK_ARG(Target,"Target")
            	HX_STACK_ARG(AlphaTolerance,"AlphaTolerance")
HXLINE( 220)		Int _hx_tmp = ::Math_obj::floor(Target->x);
HXLINE( 221)		Int _hx_tmp1 = ::Math_obj::floor(Target->y);
HXDLIN( 221)		Float _hx_tmp2 = Target->get_width();
HXDLIN( 221)		Int _hx_tmp3 = ::Std_obj::_hx_int(_hx_tmp2);
HXDLIN( 221)		Float _hx_tmp4 = Target->get_height();
HXDLIN( 221)		Int _hx_tmp5 = ::Std_obj::_hx_int(_hx_tmp4);
HXLINE( 220)		if (!(::flixel::math::FlxMath_obj::pointInCoordinates(PointX,PointY,_hx_tmp,_hx_tmp1,_hx_tmp3,_hx_tmp5))) {
HXLINE( 223)			return false;
            		}
HXLINE( 226)		Bool _hx_tmp6 = ::flixel::FlxG_obj::renderTile;
HXDLIN( 226)		if (_hx_tmp6) {
HXLINE( 228)			Target->drawFrame(null());
            		}
HXLINE( 232)		HX_VARI(  ::openfl::_legacy::display::BitmapData,test) = Target->framePixels;
HXLINE( 234)		Float _hx_tmp7 = (PointX - Target->x);
HXDLIN( 234)		Int _hx_tmp8 = ::Math_obj::floor(_hx_tmp7);
HXDLIN( 234)		Float _hx_tmp9 = (PointY - Target->y);
HXDLIN( 234)		Int _hx_tmp10 = ::Math_obj::floor(_hx_tmp9);
HXDLIN( 234)		Int Value = test->getPixel32(_hx_tmp8,_hx_tmp10);
HXDLIN( 234)		HX_VARI( Int,pixelAlpha) = ((int)((int)::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(Value) >> (int)(int)24) & (int)(int)255);
HXLINE( 236)		Bool _hx_tmp11 = ::flixel::FlxG_obj::renderTile;
HXDLIN( 236)		if (_hx_tmp11) {
HXLINE( 238)			Float _hx_tmp12 = (pixelAlpha * Target->alpha);
HXDLIN( 238)			pixelAlpha = ::Std_obj::_hx_int(_hx_tmp12);
            		}
HXLINE( 242)		return (pixelAlpha >= AlphaTolerance);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxCollision_obj,pixelPerfectPointCheck,return )

 ::flixel::group::FlxTypedGroup FlxCollision_obj::createCameraWall( ::flixel::FlxCamera Camera,hx::Null< Bool >  __o_PlaceOutside,Int Thickness,hx::Null< Bool >  __o_AdjustWorldBounds){
Bool PlaceOutside = __o_PlaceOutside.Default(true);
Bool AdjustWorldBounds = __o_AdjustWorldBounds.Default(false);
            	HX_STACK_FRAME("flixel.util.FlxCollision","createCameraWall",0x3ca8e03f,"flixel.util.FlxCollision.createCameraWall","flixel/util/FlxCollision.hx",255,0x8c8a7b84)
            	HX_STACK_ARG(Camera,"Camera")
            	HX_STACK_ARG(PlaceOutside,"PlaceOutside")
            	HX_STACK_ARG(Thickness,"Thickness")
            	HX_STACK_ARG(AdjustWorldBounds,"AdjustWorldBounds")
HXLINE( 256)		HX_VARI(  ::flixel::tile::FlxTileblock,left) = null();
HXLINE( 257)		HX_VARI(  ::flixel::tile::FlxTileblock,right) = null();
HXLINE( 258)		HX_VARI(  ::flixel::tile::FlxTileblock,top) = null();
HXLINE( 259)		HX_VARI(  ::flixel::tile::FlxTileblock,bottom) = null();
HXLINE( 261)		if (PlaceOutside) {
HXLINE( 263)			Float _hx_tmp = (Camera->x - Thickness);
HXDLIN( 263)			Int _hx_tmp1 = ::Math_obj::floor(_hx_tmp);
HXDLIN( 263)			Float _hx_tmp2 = (Camera->y + Thickness);
HXDLIN( 263)			Int _hx_tmp3 = ::Math_obj::floor(_hx_tmp2);
HXDLIN( 263)			Int _hx_tmp4 = (Camera->height - (Thickness * (int)2));
HXDLIN( 263)			left =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp1,_hx_tmp3,Thickness,_hx_tmp4);
HXLINE( 264)			Float _hx_tmp5 = (Camera->x + Camera->width);
HXDLIN( 264)			Int _hx_tmp6 = ::Math_obj::floor(_hx_tmp5);
HXDLIN( 264)			Float _hx_tmp7 = (Camera->y + Thickness);
HXDLIN( 264)			Int _hx_tmp8 = ::Math_obj::floor(_hx_tmp7);
HXDLIN( 264)			Int _hx_tmp9 = (Camera->height - (Thickness * (int)2));
HXDLIN( 264)			right =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp6,_hx_tmp8,Thickness,_hx_tmp9);
HXLINE( 265)			Float _hx_tmp10 = (Camera->x - Thickness);
HXDLIN( 265)			Int _hx_tmp11 = ::Math_obj::floor(_hx_tmp10);
HXDLIN( 265)			Float _hx_tmp12 = (Camera->y - Thickness);
HXDLIN( 265)			Int _hx_tmp13 = ::Math_obj::floor(_hx_tmp12);
HXDLIN( 265)			Int _hx_tmp14 = (Camera->width + (Thickness * (int)2));
HXDLIN( 265)			top =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp11,_hx_tmp13,_hx_tmp14,Thickness);
HXLINE( 266)			Float _hx_tmp15 = (Camera->x - Thickness);
HXDLIN( 266)			Int _hx_tmp16 = ::Math_obj::floor(_hx_tmp15);
HXDLIN( 266)			Int _hx_tmp17 = Camera->height;
HXDLIN( 266)			Int _hx_tmp18 = (Camera->width + (Thickness * (int)2));
HXDLIN( 266)			bottom =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp16,_hx_tmp17,_hx_tmp18,Thickness);
HXLINE( 268)			if (AdjustWorldBounds) {
HXLINE( 270)				HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::FlxG_obj::worldBounds;
HXDLIN( 270)				Float X = (Camera->x - Thickness);
HXDLIN( 270)				Float Y = (Camera->y - Thickness);
HXDLIN( 270)				Float Width = (Camera->width + (Thickness * (int)2));
HXDLIN( 270)				Float Height = (Camera->height + (Thickness * (int)2));
HXDLIN( 270)				_this->x = X;
HXDLIN( 270)				_this->y = Y;
HXDLIN( 270)				_this->width = Width;
HXDLIN( 270)				_this->height = Height;
            			}
            		}
            		else {
HXLINE( 275)			Int _hx_tmp19 = ::Math_obj::floor(Camera->x);
HXDLIN( 275)			Float _hx_tmp20 = (Camera->y + Thickness);
HXDLIN( 275)			Int _hx_tmp21 = ::Math_obj::floor(_hx_tmp20);
HXDLIN( 275)			Int _hx_tmp22 = (Camera->height - (Thickness * (int)2));
HXDLIN( 275)			left =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp19,_hx_tmp21,Thickness,_hx_tmp22);
HXLINE( 276)			Float _hx_tmp23 = ((Camera->x + Camera->width) - Thickness);
HXDLIN( 276)			Int _hx_tmp24 = ::Math_obj::floor(_hx_tmp23);
HXDLIN( 276)			Float _hx_tmp25 = (Camera->y + Thickness);
HXDLIN( 276)			Int _hx_tmp26 = ::Math_obj::floor(_hx_tmp25);
HXDLIN( 276)			Int _hx_tmp27 = (Camera->height - (Thickness * (int)2));
HXDLIN( 276)			right =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp24,_hx_tmp26,Thickness,_hx_tmp27);
HXLINE( 277)			Int _hx_tmp28 = ::Math_obj::floor(Camera->x);
HXDLIN( 277)			Int _hx_tmp29 = ::Math_obj::floor(Camera->y);
HXDLIN( 277)			top =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp28,_hx_tmp29,Camera->width,Thickness);
HXLINE( 278)			Int _hx_tmp30 = ::Math_obj::floor(Camera->x);
HXDLIN( 278)			Int _hx_tmp31 = (Camera->height - Thickness);
HXDLIN( 278)			bottom =  ::flixel::tile::FlxTileblock_obj::__new(_hx_tmp30,_hx_tmp31,Camera->width,Thickness);
HXLINE( 280)			if (AdjustWorldBounds) {
HXLINE( 282)				HX_VARI_NAME(  ::flixel::math::FlxRect,_this1,"_this") = ::flixel::FlxG_obj::worldBounds;
HXDLIN( 282)				Float X1 = Camera->x;
HXDLIN( 282)				Float Y1 = Camera->y;
HXDLIN( 282)				Float Width1 = Camera->width;
HXDLIN( 282)				Float Height1 = Camera->height;
HXDLIN( 282)				_this1->x = X1;
HXDLIN( 282)				_this1->y = Y1;
HXDLIN( 282)				_this1->width = Width1;
HXDLIN( 282)				_this1->height = Height1;
            			}
            		}
HXLINE( 286)		HX_VARI(  ::flixel::group::FlxTypedGroup,result) =  ::flixel::group::FlxTypedGroup_obj::__new(null());
HXLINE( 288)		result->add(left).StaticCast<  ::flixel::FlxBasic >();
HXLINE( 289)		result->add(right).StaticCast<  ::flixel::FlxBasic >();
HXLINE( 290)		result->add(top).StaticCast<  ::flixel::FlxBasic >();
HXLINE( 291)		result->add(bottom).StaticCast<  ::flixel::FlxBasic >();
HXLINE( 293)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxCollision_obj,createCameraWall,return )


FlxCollision_obj::FlxCollision_obj()
{
}

bool FlxCollision_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"pointA") ) { outValue = pointA; return true; }
		if (HX_FIELD_EQ(inName,"pointB") ) { outValue = pointB; return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"centerA") ) { outValue = centerA; return true; }
		if (HX_FIELD_EQ(inName,"centerB") ) { outValue = centerB; return true; }
		if (HX_FIELD_EQ(inName,"matrixA") ) { outValue = matrixA; return true; }
		if (HX_FIELD_EQ(inName,"matrixB") ) { outValue = matrixB; return true; }
		if (HX_FIELD_EQ(inName,"boundsA") ) { outValue = boundsA; return true; }
		if (HX_FIELD_EQ(inName,"boundsB") ) { outValue = boundsB; return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"testMatrix") ) { outValue = testMatrix; return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"createCameraWall") ) { outValue = createCameraWall_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"pixelPerfectCheck") ) { outValue = pixelPerfectCheck_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"pixelPerfectPointCheck") ) { outValue = pixelPerfectPointCheck_dyn(); return true; }
	}
	return false;
}

bool FlxCollision_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"pointA") ) { pointA=ioValue.Cast<  ::openfl::_legacy::geom::Point >(); return true; }
		if (HX_FIELD_EQ(inName,"pointB") ) { pointB=ioValue.Cast<  ::openfl::_legacy::geom::Point >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"centerA") ) { centerA=ioValue.Cast<  ::openfl::_legacy::geom::Point >(); return true; }
		if (HX_FIELD_EQ(inName,"centerB") ) { centerB=ioValue.Cast<  ::openfl::_legacy::geom::Point >(); return true; }
		if (HX_FIELD_EQ(inName,"matrixA") ) { matrixA=ioValue.Cast<  ::openfl::_legacy::geom::Matrix >(); return true; }
		if (HX_FIELD_EQ(inName,"matrixB") ) { matrixB=ioValue.Cast<  ::openfl::_legacy::geom::Matrix >(); return true; }
		if (HX_FIELD_EQ(inName,"boundsA") ) { boundsA=ioValue.Cast<  ::openfl::_legacy::geom::Rectangle >(); return true; }
		if (HX_FIELD_EQ(inName,"boundsB") ) { boundsB=ioValue.Cast<  ::openfl::_legacy::geom::Rectangle >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"testMatrix") ) { testMatrix=ioValue.Cast<  ::openfl::_legacy::geom::Matrix >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxCollision_obj_sMemberStorageInfo = 0;
static hx::StaticInfo FlxCollision_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(void *) &FlxCollision_obj::pointA,HX_HCSTRING("pointA","\xf1","\x11","\x2e","\xf7")},
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(void *) &FlxCollision_obj::pointB,HX_HCSTRING("pointB","\xf2","\x11","\x2e","\xf7")},
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(void *) &FlxCollision_obj::centerA,HX_HCSTRING("centerA","\xcc","\xf4","\xe5","\x19")},
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(void *) &FlxCollision_obj::centerB,HX_HCSTRING("centerB","\xcd","\xf4","\xe5","\x19")},
	{hx::fsObject /*::openfl::_legacy::geom::Matrix*/ ,(void *) &FlxCollision_obj::matrixA,HX_HCSTRING("matrixA","\xe0","\x42","\x67","\x93")},
	{hx::fsObject /*::openfl::_legacy::geom::Matrix*/ ,(void *) &FlxCollision_obj::matrixB,HX_HCSTRING("matrixB","\xe1","\x42","\x67","\x93")},
	{hx::fsObject /*::openfl::_legacy::geom::Matrix*/ ,(void *) &FlxCollision_obj::testMatrix,HX_HCSTRING("testMatrix","\x33","\x7c","\xbc","\xd4")},
	{hx::fsObject /*::openfl::_legacy::geom::Rectangle*/ ,(void *) &FlxCollision_obj::boundsA,HX_HCSTRING("boundsA","\x2c","\x20","\xb8","\xf3")},
	{hx::fsObject /*::openfl::_legacy::geom::Rectangle*/ ,(void *) &FlxCollision_obj::boundsB,HX_HCSTRING("boundsB","\x2d","\x20","\xb8","\xf3")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void FlxCollision_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxCollision_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::pointA,"pointA");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::pointB,"pointB");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::centerA,"centerA");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::centerB,"centerB");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::matrixA,"matrixA");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::matrixB,"matrixB");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::testMatrix,"testMatrix");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::boundsA,"boundsA");
	HX_MARK_MEMBER_NAME(FlxCollision_obj::boundsB,"boundsB");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxCollision_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::pointA,"pointA");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::pointB,"pointB");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::centerA,"centerA");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::centerB,"centerB");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::matrixA,"matrixA");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::matrixB,"matrixB");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::testMatrix,"testMatrix");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::boundsA,"boundsA");
	HX_VISIT_MEMBER_NAME(FlxCollision_obj::boundsB,"boundsB");
};

#endif

hx::Class FlxCollision_obj::__mClass;

static ::String FlxCollision_obj_sStaticFields[] = {
	HX_HCSTRING("pointA","\xf1","\x11","\x2e","\xf7"),
	HX_HCSTRING("pointB","\xf2","\x11","\x2e","\xf7"),
	HX_HCSTRING("centerA","\xcc","\xf4","\xe5","\x19"),
	HX_HCSTRING("centerB","\xcd","\xf4","\xe5","\x19"),
	HX_HCSTRING("matrixA","\xe0","\x42","\x67","\x93"),
	HX_HCSTRING("matrixB","\xe1","\x42","\x67","\x93"),
	HX_HCSTRING("testMatrix","\x33","\x7c","\xbc","\xd4"),
	HX_HCSTRING("boundsA","\x2c","\x20","\xb8","\xf3"),
	HX_HCSTRING("boundsB","\x2d","\x20","\xb8","\xf3"),
	HX_HCSTRING("pixelPerfectCheck","\x21","\x18","\xe0","\xff"),
	HX_HCSTRING("pixelPerfectPointCheck","\x5f","\xf0","\x41","\xdf"),
	HX_HCSTRING("createCameraWall","\x6b","\x04","\x3e","\xea"),
	::String(null())
};

void FlxCollision_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.util.FlxCollision","\x1a","\xc3","\x9f","\xaf");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxCollision_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxCollision_obj::__SetStatic;
	__mClass->mMarkFunc = FlxCollision_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxCollision_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxCollision_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxCollision_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxCollision_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxCollision_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxCollision_obj::__boot()
{
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",24,0x8c8a7b84)
HXLINE(  24)		pointA =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",25,0x8c8a7b84)
HXLINE(  25)		pointB =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",26,0x8c8a7b84)
HXLINE(  26)		centerA =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",27,0x8c8a7b84)
HXLINE(  27)		centerB =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",28,0x8c8a7b84)
HXLINE(  28)		matrixA =  ::openfl::_legacy::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",29,0x8c8a7b84)
HXLINE(  29)		matrixB =  ::openfl::_legacy::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",30,0x8c8a7b84)
HXLINE(  30)		testMatrix =  ::openfl::_legacy::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",31,0x8c8a7b84)
HXLINE(  31)		boundsA =  ::openfl::_legacy::geom::Rectangle_obj::__new(null(),null(),null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.util.FlxCollision","boot",0x0a2ef206,"flixel.util.FlxCollision.boot","flixel/util/FlxCollision.hx",32,0x8c8a7b84)
HXLINE(  32)		boundsB =  ::openfl::_legacy::geom::Rectangle_obj::__new(null(),null(),null(),null());
            	}
}

} // end namespace flixel
} // end namespace util
