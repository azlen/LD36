// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_math_FlxAngle
#include <flixel/math/FlxAngle.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxVelocity
#include <flixel/math/FlxVelocity.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

namespace flixel{
namespace math{

void FlxVelocity_obj::__construct() { }

Dynamic FlxVelocity_obj::__CreateEmpty() { return new FlxVelocity_obj; }

hx::ObjectPtr< FlxVelocity_obj > FlxVelocity_obj::__new()
{
	hx::ObjectPtr< FlxVelocity_obj > _hx_result = new FlxVelocity_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic FlxVelocity_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxVelocity_obj > _hx_result = new FlxVelocity_obj();
	_hx_result->__construct();
	return _hx_result;
}

void FlxVelocity_obj::moveTowardsObject( ::flixel::FlxSprite Source, ::flixel::FlxSprite Dest,hx::Null< Float >  __o_Speed,hx::Null< Int >  __o_MaxTime){
Float Speed = __o_Speed.Default(60);
Int MaxTime = __o_MaxTime.Default(0);
            	HX_STACK_FRAME("flixel.math.FlxVelocity","moveTowardsObject",0xaf722b77,"flixel.math.FlxVelocity.moveTowardsObject","flixel/math/FlxVelocity.hx",24,0xbea30ec3)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Dest,"Dest")
            	HX_STACK_ARG(Speed,"Speed")
            	HX_STACK_ARG(MaxTime,"MaxTime")
HXLINE(  25)		HX_VARI( Float,dx) = ((Dest->x + Dest->origin->x) - (Source->x + Source->origin->x));
HXDLIN(  25)		HX_VARI( Float,dy) = ((Dest->y + Dest->origin->y) - (Source->y + Source->origin->y));
HXDLIN(  25)		HX_VAR( Float,a);
HXDLIN(  25)		a = ::Math_obj::atan2(dy,dx);
HXLINE(  27)		if ((MaxTime > (int)0)) {
HXLINE(  29)			HX_VARI_NAME( Float,dx1,"dx") = ((Source->x + Source->origin->x) - (Dest->x + Dest->origin->x));
HXDLIN(  29)			HX_VARI_NAME( Float,dy1,"dy") = ((Source->y + Source->origin->y) - (Dest->y + Dest->origin->y));
HXDLIN(  29)			Float _hx_tmp = ::Math_obj::sqrt(((dx1 * dx1) + (dy1 * dy1)));
HXDLIN(  29)			HX_VARI( Int,d) = ::Std_obj::_hx_int(_hx_tmp);
HXLINE(  32)			Speed = ::Std_obj::_hx_int(((Float)d / (Float)((Float)MaxTime / (Float)(int)1000)));
            		}
HXLINE(  35)		Float _hx_tmp1 = ::Math_obj::cos(a);
HXDLIN(  35)		Source->velocity->set_x((_hx_tmp1 * Speed));
HXLINE(  36)		Float _hx_tmp2 = ::Math_obj::sin(a);
HXDLIN(  36)		Source->velocity->set_y((_hx_tmp2 * Speed));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,moveTowardsObject,(void))

void FlxVelocity_obj::accelerateTowardsObject( ::flixel::FlxSprite Source, ::flixel::FlxSprite Dest,Float Acceleration,Float MaxSpeed){
            	HX_STACK_FRAME("flixel.math.FlxVelocity","accelerateTowardsObject",0x1ebf81eb,"flixel.math.FlxVelocity.accelerateTowardsObject","flixel/math/FlxVelocity.hx",50,0xbea30ec3)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Dest,"Dest")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(MaxSpeed,"MaxSpeed")
HXLINE(  51)		HX_VARI( Float,dx) = ((Dest->x + Dest->origin->x) - (Source->x + Source->origin->x));
HXDLIN(  51)		HX_VARI( Float,dy) = ((Dest->y + Dest->origin->y) - (Source->y + Source->origin->y));
HXDLIN(  51)		HX_VAR( Float,a);
HXDLIN(  51)		a = ::Math_obj::atan2(dy,dx);
HXLINE(  52)		{
HXLINE(  52)			HX_VARI( Float,sinA) = ::Math_obj::sin(a);
HXDLIN(  52)			HX_VARI( Float,cosA) = ::Math_obj::cos(a);
HXDLIN(  52)			Source->velocity->set((int)0,(int)0);
HXDLIN(  52)			Source->acceleration->set((cosA * Acceleration),(sinA * Acceleration));
HXDLIN(  52)			Float _hx_tmp = ::Math_obj::abs((cosA * MaxSpeed));
HXDLIN(  52)			Float _hx_tmp1 = ::Math_obj::abs((sinA * MaxSpeed));
HXDLIN(  52)			Source->maxVelocity->set(_hx_tmp,_hx_tmp1);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,accelerateTowardsObject,(void))

void FlxVelocity_obj::moveTowardsMouse( ::flixel::FlxSprite Source,hx::Null< Float >  __o_Speed,hx::Null< Int >  __o_MaxTime){
Float Speed = __o_Speed.Default(60);
Int MaxTime = __o_MaxTime.Default(0);
            	HX_STACK_FRAME("flixel.math.FlxVelocity","moveTowardsMouse",0x58da686d,"flixel.math.FlxVelocity.moveTowardsMouse","flixel/math/FlxVelocity.hx",67,0xbea30ec3)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Speed,"Speed")
            	HX_STACK_ARG(MaxTime,"MaxTime")
HXLINE(  68)		HX_VARI( Float,a) = ::flixel::math::FlxAngle_obj::angleBetweenMouse(Source,null());
HXLINE(  70)		if ((MaxTime > (int)0)) {
HXLINE(  72)			HX_VARI( Float,dx) = ((Source->x + Source->origin->x) - ::flixel::FlxG_obj::mouse->screenX);
HXDLIN(  72)			HX_VARI( Float,dy) = ((Source->y + Source->origin->y) - ::flixel::FlxG_obj::mouse->screenY);
HXDLIN(  72)			Float _hx_tmp = ::Math_obj::sqrt(((dx * dx) + (dy * dy)));
HXDLIN(  72)			HX_VARI( Int,d) = ::Std_obj::_hx_int(_hx_tmp);
HXLINE(  75)			Speed = ::Std_obj::_hx_int(((Float)d / (Float)((Float)MaxTime / (Float)(int)1000)));
            		}
HXLINE(  78)		Float _hx_tmp1 = ::Math_obj::cos(a);
HXDLIN(  78)		Source->velocity->set_x((_hx_tmp1 * Speed));
HXLINE(  79)		Float _hx_tmp2 = ::Math_obj::sin(a);
HXDLIN(  79)		Source->velocity->set_y((_hx_tmp2 * Speed));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxVelocity_obj,moveTowardsMouse,(void))

void FlxVelocity_obj::accelerateTowardsMouse( ::flixel::FlxSprite Source,Float Acceleration,Float MaxSpeed){
            	HX_STACK_FRAME("flixel.math.FlxVelocity","accelerateTowardsMouse",0x2dba9c79,"flixel.math.FlxVelocity.accelerateTowardsMouse","flixel/math/FlxVelocity.hx",122,0xbea30ec3)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(MaxSpeed,"MaxSpeed")
HXLINE( 123)		HX_VARI( Float,a) = ::flixel::math::FlxAngle_obj::angleBetweenMouse(Source,null());
HXLINE( 125)		{
HXLINE( 125)			HX_VARI( Float,sinA) = ::Math_obj::sin(a);
HXDLIN( 125)			HX_VARI( Float,cosA) = ::Math_obj::cos(a);
HXDLIN( 125)			Source->velocity->set((int)0,(int)0);
HXDLIN( 125)			Source->acceleration->set((cosA * Acceleration),(sinA * Acceleration));
HXDLIN( 125)			Float _hx_tmp = ::Math_obj::abs((cosA * MaxSpeed));
HXDLIN( 125)			Float _hx_tmp1 = ::Math_obj::abs((sinA * MaxSpeed));
HXDLIN( 125)			Source->maxVelocity->set(_hx_tmp,_hx_tmp1);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxVelocity_obj,accelerateTowardsMouse,(void))

void FlxVelocity_obj::moveTowardsPoint( ::flixel::FlxSprite Source, ::flixel::math::FlxPoint Target,hx::Null< Float >  __o_Speed,hx::Null< Int >  __o_MaxTime){
Float Speed = __o_Speed.Default(60);
Int MaxTime = __o_MaxTime.Default(0);
            	HX_STACK_FRAME("flixel.math.FlxVelocity","moveTowardsPoint",0x13050698,"flixel.math.FlxVelocity.moveTowardsPoint","flixel/math/FlxVelocity.hx",160,0xbea30ec3)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Target,"Target")
            	HX_STACK_ARG(Speed,"Speed")
            	HX_STACK_ARG(MaxTime,"MaxTime")
HXLINE( 161)		HX_VARI( Float,a) = ::flixel::math::FlxAngle_obj::angleBetweenPoint(Source,Target,null());
HXLINE( 163)		if ((MaxTime > (int)0)) {
HXLINE( 165)			HX_VARI( Float,dx) = ((Source->x + Source->origin->x) - Target->x);
HXDLIN( 165)			HX_VARI( Float,dy) = ((Source->y + Source->origin->y) - Target->y);
HXDLIN( 165)			Bool _hx_tmp = Target->_weak;
HXDLIN( 165)			if (_hx_tmp) {
HXLINE( 165)				Target->put();
            			}
HXDLIN( 165)			Float _hx_tmp1 = ::Math_obj::sqrt(((dx * dx) + (dy * dy)));
HXDLIN( 165)			HX_VARI( Int,d) = ::Std_obj::_hx_int(_hx_tmp1);
HXLINE( 168)			Speed = ::Std_obj::_hx_int(((Float)d / (Float)((Float)MaxTime / (Float)(int)1000)));
            		}
HXLINE( 171)		Float _hx_tmp2 = ::Math_obj::cos(a);
HXDLIN( 171)		Source->velocity->set_x((_hx_tmp2 * Speed));
HXLINE( 172)		Float _hx_tmp3 = ::Math_obj::sin(a);
HXDLIN( 172)		Source->velocity->set_y((_hx_tmp3 * Speed));
HXLINE( 174)		Bool _hx_tmp4 = Target->_weak;
HXDLIN( 174)		if (_hx_tmp4) {
HXLINE( 174)			Target->put();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,moveTowardsPoint,(void))

void FlxVelocity_obj::accelerateTowardsPoint( ::flixel::FlxSprite Source, ::flixel::math::FlxPoint Target,Float Acceleration,Float MaxSpeed){
            	HX_STACK_FRAME("flixel.math.FlxVelocity","accelerateTowardsPoint",0xe7e53aa4,"flixel.math.FlxVelocity.accelerateTowardsPoint","flixel/math/FlxVelocity.hx",188,0xbea30ec3)
            	HX_STACK_ARG(Source,"Source")
            	HX_STACK_ARG(Target,"Target")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(MaxSpeed,"MaxSpeed")
HXLINE( 189)		HX_VARI( Float,a) = ::flixel::math::FlxAngle_obj::angleBetweenPoint(Source,Target,null());
HXLINE( 191)		{
HXLINE( 191)			HX_VARI( Float,sinA) = ::Math_obj::sin(a);
HXDLIN( 191)			HX_VARI( Float,cosA) = ::Math_obj::cos(a);
HXDLIN( 191)			Source->velocity->set((int)0,(int)0);
HXDLIN( 191)			Source->acceleration->set((cosA * Acceleration),(sinA * Acceleration));
HXDLIN( 191)			Float _hx_tmp = ::Math_obj::abs((cosA * MaxSpeed));
HXDLIN( 191)			Float _hx_tmp1 = ::Math_obj::abs((sinA * MaxSpeed));
HXDLIN( 191)			Source->maxVelocity->set(_hx_tmp,_hx_tmp1);
            		}
HXLINE( 193)		Bool _hx_tmp2 = Target->_weak;
HXDLIN( 193)		if (_hx_tmp2) {
HXLINE( 193)			Target->put();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxVelocity_obj,accelerateTowardsPoint,(void))

 ::flixel::math::FlxPoint FlxVelocity_obj::velocityFromAngle(Float Angle,Float Speed){
            	HX_STACK_FRAME("flixel.math.FlxVelocity","velocityFromAngle",0x954f2639,"flixel.math.FlxVelocity.velocityFromAngle","flixel/math/FlxVelocity.hx",204,0xbea30ec3)
            	HX_STACK_ARG(Angle,"Angle")
            	HX_STACK_ARG(Speed,"Speed")
HXLINE( 205)		HX_VARI( Float,a) = (Angle * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 207)		Float _hx_tmp = ::Math_obj::cos(a);
HXDLIN( 207)		Float X = (_hx_tmp * Speed);
HXDLIN( 207)		Float _hx_tmp1 = ::Math_obj::sin(a);
HXDLIN( 207)		HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get()->set(X,(_hx_tmp1 * Speed));
HXDLIN( 207)		point->_inPool = false;
HXDLIN( 207)		return point;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxVelocity_obj,velocityFromAngle,return )

 ::flixel::math::FlxPoint FlxVelocity_obj::velocityFromFacing( ::flixel::FlxSprite Parent,Float Speed){
            	HX_STACK_FRAME("flixel.math.FlxVelocity","velocityFromFacing",0x90de75f4,"flixel.math.FlxVelocity.velocityFromFacing","flixel/math/FlxVelocity.hx",218,0xbea30ec3)
            	HX_STACK_ARG(Parent,"Parent")
            	HX_STACK_ARG(Speed,"Speed")
HXLINE( 219)		HX_VARI( Int,FacingBitmask) = Parent->facing;
HXDLIN( 219)		HX_VAR( Int,degrees);
HXDLIN( 219)		switch((int)(FacingBitmask)){
            			case (int)1: {
HXLINE( 219)				degrees = (int)180;
            			}
            			break;
            			case (int)16: {
HXLINE( 219)				degrees = (int)0;
            			}
            			break;
            			case (int)256: {
HXLINE( 219)				degrees = (int)-90;
            			}
            			break;
            			case (int)4096: {
HXLINE( 219)				degrees = (int)90;
            			}
            			break;
            			default:{
HXLINE( 219)				if ((FacingBitmask == (int)257)) {
HXLINE( 219)					degrees = (int)-135;
            				}
            				else {
HXLINE( 219)					if ((FacingBitmask == (int)272)) {
HXLINE( 219)						degrees = (int)-45;
            					}
            					else {
HXLINE( 219)						if ((FacingBitmask == (int)4097)) {
HXLINE( 219)							degrees = (int)135;
            						}
            						else {
HXLINE( 219)							if ((FacingBitmask == (int)4112)) {
HXLINE( 219)								degrees = (int)45;
            							}
            							else {
HXLINE( 219)								degrees = (int)0;
            							}
            						}
            					}
            				}
            			}
            		}
HXDLIN( 219)		HX_VAR( Float,a);
HXDLIN( 219)		a = (degrees * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 220)		Float _hx_tmp = ::Math_obj::cos(a);
HXDLIN( 220)		Float X = (_hx_tmp * Speed);
HXDLIN( 220)		Float _hx_tmp1 = ::Math_obj::sin(a);
HXDLIN( 220)		HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get()->set(X,(_hx_tmp1 * Speed));
HXDLIN( 220)		point->_inPool = false;
HXDLIN( 220)		return point;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxVelocity_obj,velocityFromFacing,return )

Float FlxVelocity_obj::computeVelocity(Float Velocity,Float Acceleration,Float Drag,Float Max,Float Elapsed){
            	HX_STACK_FRAME("flixel.math.FlxVelocity","computeVelocity",0xd7550d81,"flixel.math.FlxVelocity.computeVelocity","flixel/math/FlxVelocity.hx",234,0xbea30ec3)
            	HX_STACK_ARG(Velocity,"Velocity")
            	HX_STACK_ARG(Acceleration,"Acceleration")
            	HX_STACK_ARG(Drag,"Drag")
            	HX_STACK_ARG(Max,"Max")
            	HX_STACK_ARG(Elapsed,"Elapsed")
HXLINE( 235)		if ((Acceleration != (int)0)) {
HXLINE( 237)			hx::AddEq(Velocity,(Acceleration * Elapsed));
            		}
            		else {
HXLINE( 239)			if ((Drag != (int)0)) {
HXLINE( 241)				HX_VARI( Float,drag) = (Drag * Elapsed);
HXLINE( 242)				Bool _hx_tmp = ((Velocity - drag) > (int)0);
HXDLIN( 242)				if (_hx_tmp) {
HXLINE( 244)					hx::SubEq(Velocity,drag);
            				}
            				else {
HXLINE( 246)					Bool _hx_tmp1 = ((Velocity + drag) < (int)0);
HXDLIN( 246)					if (_hx_tmp1) {
HXLINE( 248)						hx::AddEq(Velocity,drag);
            					}
            					else {
HXLINE( 252)						Velocity = (int)0;
            					}
            				}
            			}
            		}
HXLINE( 255)		Bool _hx_tmp2;
HXDLIN( 255)		if ((Velocity != (int)0)) {
HXLINE( 255)			_hx_tmp2 = (Max != (int)0);
            		}
            		else {
HXLINE( 255)			_hx_tmp2 = false;
            		}
HXDLIN( 255)		if (_hx_tmp2) {
HXLINE( 257)			Bool _hx_tmp3 = (Velocity > Max);
HXDLIN( 257)			if (_hx_tmp3) {
HXLINE( 259)				Velocity = Max;
            			}
            			else {
HXLINE( 261)				Bool _hx_tmp4 = (Velocity < -(Max));
HXDLIN( 261)				if (_hx_tmp4) {
HXLINE( 263)					Velocity = -(Max);
            				}
            			}
            		}
HXLINE( 266)		return Velocity;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxVelocity_obj,computeVelocity,return )

void FlxVelocity_obj::accelerateFromAngle( ::flixel::FlxSprite source,Float radians,Float acceleration,Float maxSpeed,hx::Null< Bool >  __o_resetVelocity){
Bool resetVelocity = __o_resetVelocity.Default(true);
            	HX_STACK_FRAME("flixel.math.FlxVelocity","accelerateFromAngle",0x5b8d48b9,"flixel.math.FlxVelocity.accelerateFromAngle","flixel/math/FlxVelocity.hx",280,0xbea30ec3)
            	HX_STACK_ARG(source,"source")
            	HX_STACK_ARG(radians,"radians")
            	HX_STACK_ARG(acceleration,"acceleration")
            	HX_STACK_ARG(maxSpeed,"maxSpeed")
            	HX_STACK_ARG(resetVelocity,"resetVelocity")
HXLINE( 281)		HX_VARI( Float,sinA) = ::Math_obj::sin(radians);
HXLINE( 282)		HX_VARI( Float,cosA) = ::Math_obj::cos(radians);
HXLINE( 284)		if (resetVelocity) {
HXLINE( 285)			source->velocity->set((int)0,(int)0);
            		}
HXLINE( 287)		source->acceleration->set((cosA * acceleration),(sinA * acceleration));
HXLINE( 288)		Float _hx_tmp = ::Math_obj::abs((cosA * maxSpeed));
HXDLIN( 288)		Float _hx_tmp1 = ::Math_obj::abs((sinA * maxSpeed));
HXDLIN( 288)		source->maxVelocity->set(_hx_tmp,_hx_tmp1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxVelocity_obj,accelerateFromAngle,(void))


FlxVelocity_obj::FlxVelocity_obj()
{
}

bool FlxVelocity_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"computeVelocity") ) { outValue = computeVelocity_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"moveTowardsMouse") ) { outValue = moveTowardsMouse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"moveTowardsPoint") ) { outValue = moveTowardsPoint_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"moveTowardsObject") ) { outValue = moveTowardsObject_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"velocityFromAngle") ) { outValue = velocityFromAngle_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"velocityFromFacing") ) { outValue = velocityFromFacing_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"accelerateFromAngle") ) { outValue = accelerateFromAngle_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"accelerateTowardsMouse") ) { outValue = accelerateTowardsMouse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"accelerateTowardsPoint") ) { outValue = accelerateTowardsPoint_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"accelerateTowardsObject") ) { outValue = accelerateTowardsObject_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxVelocity_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *FlxVelocity_obj_sStaticStorageInfo = 0;
#endif

static void FlxVelocity_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxVelocity_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxVelocity_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxVelocity_obj::__mClass,"__mClass");
};

#endif

hx::Class FlxVelocity_obj::__mClass;

static ::String FlxVelocity_obj_sStaticFields[] = {
	HX_HCSTRING("moveTowardsObject","\x6a","\x65","\x02","\x02"),
	HX_HCSTRING("accelerateTowardsObject","\x1e","\x34","\xa0","\x7d"),
	HX_HCSTRING("moveTowardsMouse","\xda","\xed","\x3e","\xbe"),
	HX_HCSTRING("accelerateTowardsMouse","\xa6","\x71","\x74","\x11"),
	HX_HCSTRING("moveTowardsPoint","\x05","\x8c","\x69","\x78"),
	HX_HCSTRING("accelerateTowardsPoint","\xd1","\x0f","\x9f","\xcb"),
	HX_HCSTRING("velocityFromAngle","\x2c","\x60","\xdf","\xe7"),
	HX_HCSTRING("velocityFromFacing","\xa1","\xf0","\x80","\x7c"),
	HX_HCSTRING("computeVelocity","\xb4","\xd4","\x7e","\xb6"),
	HX_HCSTRING("accelerateFromAngle","\x6c","\x25","\x16","\x9e"),
	::String(null())
};

void FlxVelocity_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.math.FlxVelocity","\x3b","\x6f","\xef","\x61");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxVelocity_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FlxVelocity_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxVelocity_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxVelocity_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxVelocity_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxVelocity_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxVelocity_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace math
